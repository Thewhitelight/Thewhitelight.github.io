<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React Native 的 NativeMoudle 生命周期</title>
    <url>/2020/06/15/react-native-moudle-lifecycle/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在混合开发时经常需要调用 Native 方法获取资源，此时需要以 NativeMoudle 的方式供前端调用。当继承ReactContextBaseJavaModule时可以重写的方法只有 onCatalystInstanceDestroy() 可以看出来是容器销毁时会调用的方法，但是其他的生命周期都没有相关方法。通过查询api发现<code>LifecycleEventListener</code>·这个listener可以监听主要的生命周期如<code>onHostResume() onHostPause() onHostDestroy()</code>通过这几个方法可以监听页面的生命周期，方便释放资源。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>但是有个很特殊的场景就是从锁屏界面调用 ReactNative 界面，这时 ReactNative 界面会在调用<code>onResume()</code>后直接调用<code>onPause()</code>,这个是由于系统机制决定的，无法更改这个逻辑。由于快速进入 pause 状态导致 NativeMoudle 的<code>onHostResume()</code>没有调用，造成无法触发这个方法里的逻辑。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>那这样的生命周期是从哪里开始调用，以什么方式开始调用呢。下面做个简单的分析。<br>当看到<code>onHostResume</code>时一定会发现和<code>Activity</code>的生命周期很相似，所有当需要从 Activity 中入手查看。本文忽略<code>ReactFragment</code>相关内容。<br><a id="more"></a></p>
<h2 id="NativeMoudle-加载流程"><a href="#NativeMoudle-加载流程" class="headerlink" title="NativeMoudle 加载流程"></a>NativeMoudle 加载流程</h2><p>ReactActivity 是 ReactNative 的入口承载页面，ReactActivity 中实际是交给ReactActivityDelegate来完成。</p>
<ol>
<li>ReactActivityDelegate 中初始化 ReactInstanceManager ，并将所有的 ReactPackage 添加进 ReactInstanceManager</li>
<li>ReactInstanceManager 中创建出所有的 ReactPackage  并将其设置进 CatalystInstanceImpl</li>
<li>CatalystInstanceImpl 中将所有 ReactPackage 传入 C++ 层，通过C++实现与js 通信</li>
</ol>
<h2 id="NativeMoudle-生命周期"><a href="#NativeMoudle-生命周期" class="headerlink" title="NativeMoudle 生命周期"></a>NativeMoudle 生命周期</h2><p>在 js 层触发 componentWillMount 时，NativeMoudle 已经初始化完成。已经可以调用相关的 ReactMethod 方法。<br>前面说 NativeMoudle 的加载流程，当 ReactInstanceManager 加载后，ReactRootView 调用 startReactApplication 时便开始在主线程上异步初始化 ReactContext、CatalystInstanceImpl。<br><figure class="highlight java"><figcaption><span>ReactInstanceManager.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化过的代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupReactContext</span><span class="params">(<span class="keyword">final</span> ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mAttachedReactRoots) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReactContextLock) &#123;</span><br><span class="line">      mCurrentReactContext = Assertions.assertNotNull(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CatalystInstance catalystInstance =</span><br><span class="line">      Assertions.assertNotNull(reactContext.getCatalystInstance());</span><br><span class="line"></span><br><span class="line">    catalystInstance.initialize();</span><br><span class="line">    <span class="comment">//调用 NativeMoudle 生命周期方法</span></span><br><span class="line">    moveReactContextToCurrentLifecycleState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ReactRoot reactRoot : mAttachedReactRoots) &#123;</span><br><span class="line">      attachRootViewToInstance(reactRoot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">moveReactContextToCurrentLifecycleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mLifecycleState == LifecycleState.RESUMED) &#123;</span><br><span class="line">    moveToResumedLifecycleState(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此方法会调用两次，在 onHostResume 里 force=false 调用，也会在 moveReactContextToCurrentLifecycleState force=true 时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">moveToResumedLifecycleState</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">  ReactContext currentContext = getCurrentReactContext();</span><br><span class="line">  <span class="keyword">if</span> (currentContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//当 currentContext 不为空且未调用过</span></span><br><span class="line">    <span class="comment">// we currently don't have an onCreate callback so we call onResume for both transitions</span></span><br><span class="line">    <span class="keyword">if</span> (force</span><br><span class="line">      || mLifecycleState == LifecycleState.BEFORE_RESUME</span><br><span class="line">      || mLifecycleState == LifecycleState.BEFORE_CREATE) &#123;</span><br><span class="line">      currentContext.onHostResume(mCurrentActivity);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mLifecycleState = LifecycleState.RESUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 LifecycleState 为 RESUMED 且 ReactContext 不为空 时便会调用 NativeMoudle 的生命周期方法 <code>onHostResume()</code>。<br>当退出 Activity 时调用 ReactInstanceManager 的 onHostPause 方法进而 调用<code>moveToBeforeResumeLifecycleState()</code><br><figure class="highlight java"><figcaption><span>ReactInstanceManager.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">moveToBeforeResumeLifecycleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ReactContext currentContext = getCurrentReactContext();</span><br><span class="line">  <span class="keyword">if</span> (currentContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLifecycleState == LifecycleState.BEFORE_CREATE) &#123;</span><br><span class="line">      currentContext.onHostResume(mCurrentActivity);</span><br><span class="line">      currentContext.onHostPause();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLifecycleState == LifecycleState.RESUMED) &#123;</span><br><span class="line">      <span class="comment">//因为 CatalystInstanceImpl 初始化后 mLifecycleState 会变为 RESUMED 所以会进入此分支</span></span><br><span class="line">      currentContext.onHostPause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mLifecycleState = LifecycleState.BEFORE_RESUME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="锁屏引起的异常流程"><a href="#锁屏引起的异常流程" class="headerlink" title="锁屏引起的异常流程"></a>锁屏引起的异常流程</h2><p>由于锁屏调用 ReactNative 界面会在页面未显示前快速调用<code>onPause</code>从而调用到 ReactInstanceManager <code>moveToBeforeResumeLifecycleState()</code>方法,使得 <code>mLifecycleState</code> 为 <code>LifecycleState.BEFORE_RESUME</code><br><figure class="highlight java"><figcaption><span>ReactInstanceManager.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">moveToBeforeResumeLifecycleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ReactContext currentContext = getCurrentReactContext();</span><br><span class="line">  <span class="keyword">if</span> (currentContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLifecycleState == LifecycleState.BEFORE_CREATE) &#123;</span><br><span class="line">      currentContext.onHostResume(mCurrentActivity);</span><br><span class="line">      currentContext.onHostPause();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLifecycleState == LifecycleState.RESUMED) &#123;</span><br><span class="line">      currentContext.onHostPause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//此处更改了 mLifecycleState 状态</span></span><br><span class="line">  mLifecycleState = LifecycleState.BEFORE_RESUME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>moveReactContextToCurrentLifecycleState()</code>中<code>mLifecycleState==LifecycleState.RESUMED</code>时才会调用 NativeMoudle 的<code>onHostResume()</code>,但现在已经不会调用到<code>moveToBeforeResumeLifecycleState</code>,导致在 NativeMoudle 的<code>onHostResume()</code>代码都不会调用。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>将<code>moveReactContextToCurrentLifecycleState()</code>修改下<br><figure class="highlight java"><figcaption><span>ReactInstanceManager.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">moveReactContextToCurrentLifecycleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注释掉原有的状态判断，可以在任意状态下调用    </span></span><br><span class="line">  <span class="comment">//if (mLifecycleState == LifecycleState.RESUMED) &#123;</span></span><br><span class="line">    moveToResumedLifecycleState(<span class="keyword">true</span>);</span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  而在<code>moveToResumedLifecycleState()</code>里含有关于状态的判断，所以不用担心会重复调用<code>onHostResume()</code>引起其他问题。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native 版本校验</title>
    <url>/2020/05/11/react-native-check-version/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们业务的 SDK 包含 ReactNative 方案,所以必须依赖 React Native 的 AAR，但是最近对接的客户有自己依赖的版本，和我们使用的版本不同，所以需要我们的 React Nativ 代码运行在他们使用的版本上。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当 React Native 版本和 Native 版本不一致时，会弹出红框提示<br><div class="note danger">
            <p>React Native version mismatch.<br>JavaScript version:0.xx.x<br>Native Version:0.xx.x</p>
          </div></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>根据提示在源码里搜索发现，来自于<a href="https://github.com/facebook/react-native/blob/aee88b6843cea63d6aa0b5879ad6ef9da4701846/Libraries/Core/ReactNativeVersionCheck.js">Libraries/Core/ReactNativeVersionCheck.js</a>这个文件里，根据文件注释可以看出是专门做版本校验<br><a id="more"></a><br><figure class="highlight js"><figcaption><span>ReactNativeVersionCheck.js</span></figcaption><table><tr><td class="code"><pre><span class="line">exports.checkVersions = <span class="function"><span class="keyword">function</span> <span class="title">checkVersions</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nativeVersion = Platform.constants.reactNativeVersion;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    ReactNativeVersion.version.major !== nativeVersion.major ||</span><br><span class="line">    ReactNativeVersion.version.minor !== nativeVersion.minor</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`React Native version mismatch.\n\nJavaScript version: <span class="subst">$&#123;_formatVersion(</span></span></span><br><span class="line"><span class="string"><span class="subst">        ReactNativeVersion.version,</span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span>\n`</span> +</span><br><span class="line">        <span class="string">`Native version: <span class="subst">$&#123;_formatVersion(nativeVersion)&#125;</span>\n\n`</span> +</span><br><span class="line">        <span class="string">'Make sure that you have rebuilt the native code. If the problem '</span> +</span><br><span class="line">        <span class="string">'persists try clearing the Watchman and packager caches with '</span> +</span><br><span class="line">        <span class="string">'`watchman watch-del-all &amp;&amp; react-native start --reset-cache`.'</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看出如果是 path 兼容版本则不会弹框提示，非兼容版本时会弹框警告，如果要想去掉弹框提示，则直接注释掉这个校验代码，再使用命令行重新打包 js 代码即可。</p>
<h1 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h1><p>根据上面代码可以看出，根据命名大概可以猜出<code>ReactNativeVersion</code>是 js 侧的版本号， <code>Platform.constants.reactNativeVersion</code>是 Native 侧的版本号。<br>从 ReactNativeVersionCheck 文件的导包可以看到他们的定义目录<br><figure class="highlight js"><figcaption><span>ReactNativeVersionCheck.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Platform <span class="keyword">from</span> <span class="string">'../Utilities/Platform'</span>;</span><br><span class="line"><span class="keyword">const</span> ReactNativeVersion = <span class="built_in">require</span>(<span class="string">'./ReactNativeVersion'</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过搜索源码发现 ReactNativeVersionCheck.js-&gt;Platform.android.js-&gt;NativePlatformConstantsAndroid.js(PlatformConstants)-&gt;AndroidInfoModule.java-&gt;ReactNativeVersion.java 在这里我们发现了定义的地方<br><figure class="highlight java"><figcaption><span>ReactNativeVersion.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactNativeVersion</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; VERSION = MapBuilder.&lt;String, Object&gt;of(</span><br><span class="line">      <span class="string">"major"</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="string">"minor"</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="string">"patch"</span>, <span class="number">0</span>,</span><br><span class="line">      <span class="string">"prerelease"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是都是 0 还未赋值，看到有这样的注释<code>* @generated by scripts/bump-oss-version.js</code>，原来是通过脚本动态赋值的。<br>查看脚本发现<br><figure class="highlight js"><figcaption><span>bump-oss-version.js</span></figcaption><table><tr><td class="code"><pre><span class="line">fs.writeFileSync(</span><br><span class="line">  <span class="string">'ReactAndroid/src/main/java/com/facebook/react/modules/systeminfo/ReactNativeVersion.java'</span>,</span><br><span class="line">  cat(<span class="string">'scripts/versiontemplates/ReactNativeVersion.java.template'</span>)</span><br><span class="line">    .replace(<span class="string">'$&#123;major&#125;'</span>, major)</span><br><span class="line">    .replace(<span class="string">'$&#123;minor&#125;'</span>, minor)</span><br><span class="line">    .replace(<span class="string">'$&#123;patch&#125;'</span>, patch)</span><br><span class="line">    .replace(</span><br><span class="line">      <span class="string">'$&#123;prerelease&#125;'</span>,</span><br><span class="line">      prerelease !== <span class="literal">undefined</span> ? <span class="string">`"<span class="subst">$&#123;prerelease&#125;</span>"`</span> : <span class="string">'null'</span>,</span><br><span class="line">    ),</span><br><span class="line">  <span class="string">'utf-8'</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(</span><br><span class="line">  <span class="string">'ReactCommon/cxxreact/ReactNativeVersion.h'</span>,</span><br><span class="line">  cat(<span class="string">'scripts/versiontemplates/ReactNativeVersion.h.template'</span>)</span><br><span class="line">    .replace(<span class="string">'$&#123;major&#125;'</span>, major)</span><br><span class="line">    .replace(<span class="string">'$&#123;minor&#125;'</span>, minor)</span><br><span class="line">    .replace(<span class="string">'$&#123;patch&#125;'</span>, patch)</span><br><span class="line">    .replace(</span><br><span class="line">      <span class="string">'$&#123;prerelease&#125;'</span>,</span><br><span class="line">      prerelease !== <span class="literal">undefined</span> ? <span class="string">`"<span class="subst">$&#123;prerelease&#125;</span>"`</span> : <span class="string">'""'</span>,</span><br><span class="line">    ),</span><br><span class="line">  <span class="string">'utf-8'</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(</span><br><span class="line">  <span class="string">'Libraries/Core/ReactNativeVersion.js'</span>,</span><br><span class="line">  cat(<span class="string">'scripts/versiontemplates/ReactNativeVersion.js.template'</span>)</span><br><span class="line">    .replace(<span class="string">'$&#123;major&#125;'</span>, major)</span><br><span class="line">    .replace(<span class="string">'$&#123;minor&#125;'</span>, minor)</span><br><span class="line">    .replace(<span class="string">'$&#123;patch&#125;'</span>, patch)</span><br><span class="line">    .replace(</span><br><span class="line">      <span class="string">'$&#123;prerelease&#125;'</span>,</span><br><span class="line">      prerelease !== <span class="literal">undefined</span> ? <span class="string">`'<span class="subst">$&#123;prerelease&#125;</span>'`</span> : <span class="string">'null'</span>,</span><br><span class="line">    ),</span><br><span class="line">  <span class="string">'utf-8'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>分别给 js，Android，iOS 赋值的代码。到这里我们就了解了 React Native 版本校验的逻辑。通过脚本动态生成三端的版本号。</p>
<h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><p>在 bump-oss-version.js 里发现这段代码，感觉挺难理解为啥要做这样的限制。<br><figure class="highlight js"><figcaption><span>bump-oss-version.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// - check that argument version matches branch</span></span><br><span class="line"><span class="comment">// e.g. 0.33.1 or 0.33.0-rc4</span></span><br><span class="line"><span class="keyword">let</span> version = argv._[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (!version || version.indexOf(versionMajor) !== <span class="number">0</span>) &#123;</span><br><span class="line">  echo(</span><br><span class="line">    <span class="string">`You must pass a tag like 0.<span class="subst">$&#123;versionMajor&#125;</span>.[X]-rc[Y] to bump a version`</span>,</span><br><span class="line">  );</span><br><span class="line">  exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 上传下载操作</title>
    <url>/2020/03/09/maven-related/</url>
    <content><![CDATA[<p>Java 开发中使用最多的构建工具就是 Maven，Android 的 Gradle 构建工具使用的版本仓库也是 Maven，对于使用脚本打包出产物上传至远程仓库的方式已经很熟悉，但是有时候需要从 Maven 下载产物或者直接上传产物。如果每次都在 Maven 的服务端页面操作就很麻烦。所以如果使用脚本就很方便。<br><a id="more"></a></p>
<h1 id="配置-mvn"><a href="#配置-mvn" class="headerlink" title="配置 mvn"></a>配置 mvn</h1><h2 id="安装-mvn-命令行，mac-下可以使用-brew-install-mvn。"><a href="#安装-mvn-命令行，mac-下可以使用-brew-install-mvn。" class="headerlink" title="安装 mvn 命令行，mac 下可以使用 brew install mvn。"></a>安装 mvn 命令行，mac 下可以使用 <code>brew install mvn</code>。</h2><h2 id="配置-mvn-文件"><a href="#配置-mvn-文件" class="headerlink" title="配置 mvn 文件"></a>配置 mvn 文件</h2><p>当 mvn 安装好后命令行执行<code>which mvn</code>查看安装路径，如<code>/usr/local/apache-maven-3.6.3/bin/mvn</code>，然后<code>cd apache-maven-3.6.3/conf/</code>可以在这个目录下发现<code>settings.xml</code>，打开 xml 文件配置如下<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加 server 节点，id 可以任意写，注意后面的命令行参数会用到，username password 为私有 maven 配置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>***<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>***<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="命令行上传产物"><a href="#命令行上传产物" class="headerlink" title="命令行上传产物"></a>命令行上传产物</h1><p>以上传<code>com.android.support:appcompat-v7:28.0.0</code>为例,比如在当前目录下有<code>appcompat-v7-28.0.0.aar</code>这个包<br>使用 下面命令行即可上传<br><code>mvn deploy:deploy-file -Dfile=appcompat-v7-28.0.0.aar -DgroupId=com.android.support -DartifactId=appcompat-v7 -Dversion=28.0.0 -Dpackaging=aar -Durl=https://www.***.com/repository/maven-releases/ -DrepositoryId=releases -DpomFile=appcompat-v7-28.0.0.pom</code></p>
<p><code>-DrepositoryId</code>即为<code>xml</code>中配置的 id，名字必须相同<br><code>-Dpackaging</code>即为上传产物类型<br><code>-Durl</code>即为上传地址<br><code>-DpomFile</code>即为上传的 pom 文件，可选参数</p>
<h1 id="下载产物"><a href="#下载产物" class="headerlink" title="下载产物"></a>下载产物</h1><h2 id="mvn-install"><a href="#mvn-install" class="headerlink" title="mvn install"></a>mvn install</h2><p>如果有 pom 文件 直接在目录下执行 <code>mvn install</code> 就可以下载，但是前提得有 pom 较为麻烦</p>
<h2 id="脚本下载"><a href="#脚本下载" class="headerlink" title="脚本下载"></a>脚本下载</h2><p>模拟 support 包的下载路径是这样<code>https://www.***.com/repository/maven-releases/com/android/support/appcompat-v7/28.0.0/appcompat-v7-28.0.0.pom</code>，观察 url 我们就可以发现是通过依赖包名就可以构造出来的路径，<code>aar、jar、sourec.jar</code>都是类似的路径。我们就可以通过<code>curl</code>命令构造路径直接下载到想要的产物，由于脚本过于简单就不做演示。</p>
<h1 id="批量获取-maven-产物"><a href="#批量获取-maven-产物" class="headerlink" title="批量获取 maven 产物"></a>批量获取 maven 产物</h1><p>由于业务需要查看 maven 里产物的内容，但是一个一个下载查看就很麻烦，所以抓包看了下 maven 搜索页面发现这个链接<code>https://www.***.com/service/extdirect</code>,在加上抓取的 Head 我们就可以模拟出一个正常的请求从而获取到想要的所有的产物链接，也可以通过开放 API(<a href="https://www.***.com/service/rest/v1/search" target="_blank" rel="noopener">https://www.***.com/service/rest/v1/search</a>) 获取全部产物，通过解析<code>json</code>进一步获取下载地址，通过<code>curl</code>即可下载到产物，最后通过<code>unzip</code>就可以拆包解析产物。所以流程有点长但是一次写好脚本以后，就可以很方便的重复使用。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>mvn 自己不算了解，在工作实践中慢慢的了解，多次尝试总结出一点使用方法。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>用 BECAUSE 驾驭你的 Gradle 依赖 (译)</title>
    <url>/2020/02/20/gradle-dependencies-because/</url>
    <content><![CDATA[<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>你是否知道可以指定使用某个依赖或者某个版本的依赖的原因.<br>是的,在<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/Dependency.html#because-java.lang.String-" target="_blank" rel="noopener">API</a>和<a href="https://docs.gradle.org/current/userguide/declaring_dependencies.html#sec:documenting-dependencies" target="_blank" rel="noopener">DOCS</a>中<br><div class="note info">
            <p>void because?(@Nullable String reason)</p><p>Sets the reason why this dependency should be used.<br>Since:<br>4.6</p>
          </div><br><a id="more"></a><br>基本用法如下所示<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">"com.blundell:app-auth android:1.2.3"</span>) &#123;</span><br><span class="line">    because <span class="string">"We use fragment auth, original AppAuth library does not support this feature."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Gradle 允许你写一两句为什么选择改依赖的句子，并且可以使用以下命令提取该注释，以显示在报告中：<br><code>gradle -q dependencyInsight –dependency app-auth android</code><br>但是这不是我有兴趣使用它的原因！<br>此功能最主要的收益就是使用在敏捷团队中，总有一些使用某种依赖的原因，有时你会坚持使用早前版本以实现兼容性。有时你因为编译时间和没有反射需要使用一个解析库里而不是另一个。有时你需要支持多个国家并且是唯一的依赖，即使他不是标准的做法。<br>所有这个原因通常都会消失在时间的迷雾中，如果幸运的话，它们会出现在 git commit message 中（但是说实话，它们不会首先被检查）。<br>使用 because 函数可以使你对特定的业务决策进行说明，并想团队其他成员明确说明为啥这么做。 与希望/查找/忽略和更改依赖项的人一起节省时间，精力和潜在的错误。<br>所以开始使用它！ 🙂<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">"com.blundell:android-blog:1.2.3"</span>) &#123;</span><br><span class="line">    because <span class="string">"If we didn't Blundell might cry."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://blog.blundellapps.co.uk/tame-your-gradle-dependencies-just-because/3" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidX 迁移脚本实现</title>
    <url>/2019/12/07/androidx-migrate-script/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>现在 Android 10 早已经发布,当 targetVersion 为29时必须使用 AndroidX 并且现在新建项目时已经必须勾选 AndriodX 选项了,所以需要开始迁移工作了,有些三方库也只提供 AndroidX 版本,我们遇到 QQ 音乐和 GoogleMap 的 SDK 就只提供 AndroidX 版本.如果对于单个工程而言只需要 Refactor-&gt;Migrate to AndroiX 即可以完成自动迁移,但是对于有更多项目而言使用这样的方式虽然可以完成迁移,但是太过于繁琐,也不好统一 AndroidX 库的版本.为了方便整个团队项目进行迁移,所以使用脚本进行迁移会方便很多.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>整个流程很简单</p>
<ol>
<li>checkout 新分支</li>
<li>升级新 gradle 版本</li>
<li>升级 gradle tool 版本</li>
<li>gradle.properties 添加 AndroidX 支持</li>
<li>替换工程里所有 support 包名</li>
<li>替换工程里所有 support 依赖</li>
<li>添加混淆文件</li>
</ol>
<p>梳理完成流程,就可以动手迁移了.需要注意 AndroidX 必须使用 gradle tool 3.2 版本以上,为了保证兼容性,工程当前最好使用 supprot 28 的依赖.<br><a id="more"></a></p>
<h2 id="checkout-迁移新分支"><a href="#checkout-迁移新分支" class="headerlink" title="checkout 迁移新分支"></a>checkout 迁移新分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(cd .. | git branch androidx_migrate)</span><br><span class="line">$(cd .. | git checkout androidx_migrate)</span><br></pre></td></tr></table></figure>
<h2 id="升级-gradle-版本"><a href="#升级-gradle-版本" class="headerlink" title="升级 gradle 版本"></a>升级 gradle 版本</h2><p>将 gradle 升级至最新.<code>&gt;/dev/null</code>相当于捕获异常信息.<br><code>./gradlew wrapper --gradle-version 5.4.1 &gt;/dev/null</code></p>
<h2 id="升级-gradle-tools"><a href="#升级-gradle-tools" class="headerlink" title="升级 gradle tools"></a>升级 gradle tools</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span>(sed -i "" "s/com.android.tools.build:gradle:.*/com.android.tools.build:gradle:3.5.2/g" $&#123;BUILD_FILE&#125;)</span><br></pre></td></tr></table></figure>
<p><code>${BUILD_FILE}</code>为根目录的<code>build.gradle</code>,替换掉老版本.注意这里的 gradle tool 应该与 gradle 版本对应.</p>
<h2 id="修改-gradle-properties"><a href="#修改-gradle-properties" class="headerlink" title="修改 gradle.properties"></a>修改 gradle.properties</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo '\nandroid.useAndroidX=true</span><br><span class="line">android.enableJetifier=true' &gt;&gt;$PROJECT_DIR/gradle.properties</span><br></pre></td></tr></table></figure>
<p><code>android.useAndroidX=true</code>Android 插件会使用对应的 AndroidX 库（而非支持库）<br><code>android.enableJetifier=true</code>Android 插件会通过重写其二进制文件来自动迁移现有的第三方库以使用 AndroidX</p>
<h2 id="替换-support-包"><a href="#替换-support-包" class="headerlink" title="替换 support 包"></a>替换 support 包</h2><p>首先应该找到 support 与 androidx 的对应关系,不过 google 已经帮我们整理好这份<a href="https://developer.android.com/jetpack/androidx/migrate/class-mappings" target="_blank" rel="noopener">文档</a>,通过关系命令行替换掉相应的包名就可以了<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from_pkgs=""</span><br><span class="line">replace=""</span><br><span class="line">while IFS=, read -r from_pkg to_pkg</span><br><span class="line">do</span><br><span class="line">    from_pkgs+=" -e $from_pkg"</span><br><span class="line">    replace+="; s/$from_pkg/$to_pkg/g"</span><br><span class="line">done &lt;&lt;&lt; "$(tail -n +2 $MAPPING_FILE)"</span><br><span class="line"></span><br><span class="line">rg --files-with-matches -t java -t kotlin -t xml -F $from_pkgs $PROJECT_DIR | xargs perl -pi -e "$replace"</span><br></pre></td></tr></table></figure></p>
<p><code>$MAPPING_FILE)</code>为 androidx_class_map.csv 的目录,这个文件就是 gooogle 提供的文档,但是用官方的文件出现了替换后对应不正确的问题,我自己改变下文件里的顺序后,则可以正常使用了.<br><code>$(tail -n +2 $MAPPING_FILE)</code>相当于<code>cat</code>只是从第2行读取到文件结尾.因为第1行非 support 对应关系.<br><code>replace+=&quot;; s/$from_pkg/$to_pkg/g&quot;</code>是用来进行替换的规则,使用过<code>sed</code>就可以理解这个操作.意为将本行里的<code>$to_pkg</code>替换为<code>$from_pkg</code>,当有多个内容替换时用<code>;</code>分隔.<br><code>rg</code>是比<code>find</code>更快的搜索工具.通过<code>rg</code>搜索到我们需要替换的文件类型,它内置了很多文件类型,文末参考里有详细教程.<code>xml</code>里的布局也需要替换掉,所以也需要把包含 support 包的相关文件搜索出来.<br><code>xargs</code>是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具.<br><code>perl</code>的正则支持比<code>sed</code>好很多,所以使用它可以少踩很多正则上的坑.</p>
<h2 id="替换-support-依赖"><a href="#替换-support-依赖" class="headerlink" title="替换 support 依赖"></a>替换 support 依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from_pkgs=""</span><br><span class="line">replace=""</span><br><span class="line">while IFS=, read -r from_pkg to_pkg</span><br><span class="line">do</span><br><span class="line">    from_pkgs+=" -e $from_pkg"</span><br><span class="line">    replace+="; s/(\"|')$from_pkg.*(\"|')/\"$to_pkg\"/g"</span><br><span class="line">    #如果使用sed 正则就需要写成这种形式,太过繁琐了</span><br><span class="line">    #replace+="; s/\(\\\"\|'\)$from_pkg.*\(\\\"\|'\)/\\\"$to_pkg\\\"/g"</span><br><span class="line">done &lt;&lt;&lt; "$(tail -n +2 $ARTIFACT_MAPPING_FILE)"</span><br><span class="line"></span><br><span class="line">rg --files-with-matches -t groovy -F $from_pkgs $PROJECT_DIR | xargs perl -pi -e "$replace"</span><br></pre></td></tr></table></figure>
<p>和替换 support 包的代码差不多,只是换了读取的文件,只是这里的正则稍有稍有不同.<br>在项目里会有各种形式的依赖写法如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">api &quot;com.android.support:support-v4:$&#123;rootProject.ext.supportLibVersion&#125;&quot;</span><br><span class="line">api &quot;com.android.support:support-v4:28.0.0&quot;</span><br><span class="line">api &apos;com.android.support:support-v4:28.0.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>所以需要<code>(&quot;|&#39;)package.*(&quot;|&#39;)</code>匹配所有的形式去替换成我们需要的版本.<br><code>$ARTIFACT_MAPPING_FILE</code>为依赖的映射文件.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Old build artifact,AndroidX build artifact</span><br><span class="line">com.android.support:support-v4:,androidx.legacy:legacy-support-v4:1.0.0</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>1.0.0</code>则可以写成统一的依赖版本.比如<code>${rootProject.ext.v4Version}</code>这样对于便于统一版本管理.</p>
<h2 id="混淆文件"><a href="#混淆文件" class="headerlink" title="混淆文件"></a>混淆文件</h2><p>由于包名变化所以需要新增混淆文件如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-dontwarn com.google.android.material.**</span><br><span class="line">-keep class com.google.android.material.** &#123; *; &#125;</span><br><span class="line"></span><br><span class="line">-dontwarn androidx.**</span><br><span class="line">-keep class androidx.** &#123; *; &#125;</span><br><span class="line">-keep interface androidx.** &#123; *; &#125;</span><br></pre></td></tr></table></figure></p>
<p>总结<br>至此就完成这个那个项目迁移,整个过程根据工程大小会耗时几到几十秒钟,大量的时间消耗在升级 gradle,检索替换文件耗时很少.掌握一些脚本可以极大的提高我们的开发效率.<br><a href="https://github.com/Thewhitelight/androidx_migrate_scripts">迁移脚本源码</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.hi-linux.com/posts/29245.html" target="_blank" rel="noopener">rg 教程</a><br><a href="https://developer.android.com/jetpack/androidx" target="_blank" rel="noopener">官方迁移文档</a><br><a href="https://gist.github.com/loganj/7535a13e98be83460f362b63dbd13e07" target="_blank" rel="noopener">参考迁移脚本</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>提取 Git Messages 生成 ChangeLog</title>
    <url>/2019/11/18/git-commit-message-generate-changelog/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>随着版本迭代越来越多,我们需要每次手动修改 ChangeLog,多人维护项目则容易忘记填写,并且组件化后每个模块多人维护,容易忘记填写.Module 里填写了 ChangeLog 但是 App 壳项目也要填写相同内容,也是比较麻烦的事.所以需要引入自动化来降低我们手动维护的成本.<br><a id="more"></a></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>主要问题是解决手动维护的问题,所以解决办法自然而然就是使用自动化方案,那么怎么交给自动化处理呢,自然是交给 Git 和 Shell 了.我们通过获取最近两个 git tag 之间所有的 commit message,然后筛选符合规则的 messge,把这些 message 合成然后生成 ChangeLog,这样就生成 Modlue 的 ChangeLog,然后我们可以把 ChangeLog 文件推到一个指定仓库里,然后通过特定脚本合成 App 的 ChangeLog.为了规范 commit message ,所以也需要用到 git hook 在 commit 的时候去检查 message 是否符合我们的规范.</p>
<h2 id="commit-message-规范"><a href="#commit-message-规范" class="headerlink" title="commit message 规范"></a>commit message 规范</h2><p>要生成 ChangeLog 就需要填写符合规则的 message,我们参考<a href="https://github.com/angular/angular/commits/master">Angular Commit 规范</a>,然后做了相应的简化.<br>commit message 格式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: subject</span><br><span class="line"></span><br><span class="line">body</span><br><span class="line"></span><br><span class="line">footer</span><br></pre></td></tr></table></figure></p>
<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>Header 部分只有一行，包括两个字段：type（必需）和 subject（必需）。</p>
<h4 id="type-用于说明-commit-的类别，只允许使用下面3个标识。"><a href="#type-用于说明-commit-的类别，只允许使用下面3个标识。" class="headerlink" title="type 用于说明 commit 的类别，只允许使用下面3个标识。"></a>type 用于说明 commit 的类别，只允许使用下面3个标识。</h4><ul>
<li>feat 新功能（feature）</li>
<li>fix 修补bug</li>
<li>other</li>
</ul>
<p>如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。<br><strong>如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。</strong></p>
<h4 id="subject-是-commit-目的的简短描述，不超过50个字符。"><a href="#subject-是-commit-目的的简短描述，不超过50个字符。" class="headerlink" title="subject 是 commit 目的的简短描述，不超过50个字符。"></a>subject 是 commit 目的的简短描述，不超过50个字符。</h4><p>以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes<br>第一个字母大写<br>结尾不加句号</p>
<h3 id="body-描述为什么修改-做了什么样的修改-以及开发的思路等等"><a href="#body-描述为什么修改-做了什么样的修改-以及开发的思路等等" class="headerlink" title="body 描述为什么修改, 做了什么样的修改, 以及开发的思路等等"></a>body 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</h3><h3 id="footer-放-Breaking-Changes-或-Closed-Issues"><a href="#footer-放-Breaking-Changes-或-Closed-Issues" class="headerlink" title="footer 放 Breaking Changes 或 Closed Issues"></a>footer 放 Breaking Changes 或 Closed Issues</h3><h2 id="Git-Commit-工具"><a href="#Git-Commit-工具" class="headerlink" title="Git Commit 工具"></a>Git Commit 工具</h2><p>Message规则很简单,如果养成习惯很容易上手,如果刚开始不适应可以使用下面的方法</p>
<h3 id="配置-git-模版"><a href="#配置-git-模版" class="headerlink" title="配置 git 模版"></a>配置 git 模版</h3><ol>
<li><p>在git全局配置里进行设置，linx/mac 进入文件<code>.gitconfig</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi ~/.gitconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>若不存在[commit] template，则设置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[commit]</span><br><span class="line">        template = /Users/&lt;name&gt;/.myCommitMsg</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置模板完毕后，下一步进行模板内容的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi /Users/&lt;name&gt;/.myCommitMsg</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>粘入以下内容保存即可<br>模版可以根据自己喜好随意配置,但是 Header 的格式和内容一定要保证正确<br>使用时修改为自己提交的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: subject</span><br><span class="line"></span><br><span class="line">body</span><br><span class="line"></span><br><span class="line">footer</span><br><span class="line"></span><br><span class="line"># - type: </span><br><span class="line">#    feat(新特性), </span><br><span class="line">#    fix(修改问题), </span><br><span class="line">#    other(其他任何修改), </span><br><span class="line"># - subject</span><br><span class="line">#   提交描述</span><br><span class="line"># - body:</span><br><span class="line">#    描述为什么修改, 做了什么样的修改, 以及开发的思路</span><br><span class="line"># - footer:</span><br><span class="line">#    放 Breaking Changes 或 Closed Issues</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>若使用 terminal 则使用<code>git commit</code></li>
</ol>
<p>若使用 sourcetree 等 git 管理软件，则需要重启软件才能生效。</p>
<h3 id="Sourcetree"><a href="#Sourcetree" class="headerlink" title="Sourcetree"></a>Sourcetree</h3><p>设置-&gt;提交模版-&gt;自定义,可以使用填入上述模版,并且只针对此项目生效.如果使用全局配置,参考上条配置方式.</p>
<h3 id="git-cz"><a href="#git-cz" class="headerlink" title="git cz"></a>git cz</h3><p>安装<a href="https://github.com/commitizen/cz-cli">git cz</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &apos;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&apos; &gt; ~/.czrc</span><br></pre></td></tr></table></figure></p>
<p>使用<code>git cz</code>代替<code>git commit</code>命令,会出现提交选项,按规则提交就可以,如下所示</p>
<p><img src="https://raw.githubusercontent.com/commitizen/cz-cli/master/meta/screenshots/add-commit.png" alt></p>
<p>然后在根据对应的提示下,写入内容即可完成一次提交<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  sh git:(master) ✗ git cz</span><br><span class="line">cz-cli@4.0.3, cz-conventional-changelog@3.0.1</span><br><span class="line"></span><br><span class="line">? Select the type of change that you're committing: feat:        A new feature</span><br><span class="line">? What is the scope of this change (e.g. component or file name): (press enter t</span><br><span class="line">o skip)</span><br><span class="line">? Write a short, imperative tense description of the change (max 94 chars):</span><br><span class="line"> (4) test</span><br><span class="line">? Provide a longer description of the change: (press enter to skip)</span><br><span class="line"></span><br><span class="line">? Are there any breaking changes? Yes</span><br><span class="line">? A BREAKING CHANGE commit requires a body. Please enter a longer description of the commit</span><br><span class="line">itself:</span><br><span class="line"> -</span><br><span class="line">? Describe the breaking changes:</span><br><span class="line"></span><br><span class="line">? Does this change affect any open issues? No</span><br></pre></td></tr></table></figure></p>
<p>但是此格式不符合我们的规范,已经不能使用.</p>
<h3 id="Android-Studio-Commit-Message-插件"><a href="#Android-Studio-Commit-Message-插件" class="headerlink" title="Android Studio Commit Message 插件"></a>Android Studio Commit Message 插件</h3><p>使用<a href="https://plugins.jetbrains.com/plugin/9364-commit-message-template" target="_blank" rel="noopener">Commit Message Template</a>在<code>Settings &gt; Tools &gt; Commit Message Template</code>中填入文章开始的格式.</p>
<h3 id="git-cz-1"><a href="#git-cz-1" class="headerlink" title="git cz"></a>git cz</h3><p>安装<a href="https://github.com/commitizen/cz-cli">git cz</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &apos;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&apos; &gt; ~/.czrc</span><br></pre></td></tr></table></figure></p>
<p>但是此格式不符合我们的规范,已经不能使用.</p>
<h3 id="Android-Studio-Commit-Message-插件-1"><a href="#Android-Studio-Commit-Message-插件-1" class="headerlink" title="Android Studio Commit Message 插件"></a>Android Studio Commit Message 插件</h3><p>使用<a href="https://plugins.jetbrains.com/plugin/9364-commit-message-template" target="_blank" rel="noopener">Commit Message Template</a>在<code>Settings &gt; Tools &gt; Commit Message Template</code>中填入文章开始的格式.</p>
<h3 id="git-cz-2"><a href="#git-cz-2" class="headerlink" title="git cz"></a>git cz</h3><p>安装<a href="https://github.com/commitizen/cz-cli">git cz</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line">echo &apos;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&apos; &gt; ~/.czrc</span><br></pre></td></tr></table></figure></p>
<p>使用<code>git cz</code>代替<code>git commit</code>命令,会出现提交选项,按规则提交就可以,如下所示<br>但是此格式不符合我们的规范,已经不能使用.</p>
<h3 id="Android-Studio-Commit-Message-插件-2"><a href="#Android-Studio-Commit-Message-插件-2" class="headerlink" title="Android Studio Commit Message 插件"></a>Android Studio Commit Message 插件</h3><p>使用<a href="https://plugins.jetbrains.com/plugin/9364-commit-message-template" target="_blank" rel="noopener">Commit Message Template</a>在<code>Settings &gt; Tools &gt; Commit Message Template</code>中填入文章开始的格式.<br>这样就可以在提交时点击选择模版,我们基于模版修改就可以了.</p>
<h2 id="生成-Module-的-ChangeLog"><a href="#生成-Module-的-ChangeLog" class="headerlink" title="生成 Module 的 ChangeLog"></a>生成 Module 的 ChangeLog</h2><p>简单归纳步骤如下:</p>
<ol>
<li>git tag 获取最近的两个tag</li>
<li>获取两个tag之间的commit message</li>
<li>使用脚本清洗 log,筛选符合规则的 message</li>
<li>生成changelog.md<br>脚本使用 shell 编写,所以对其需要有稍微的了解.</li>
</ol>
<h3 id="获取最近两个-tag"><a href="#获取最近两个-tag" class="headerlink" title="获取最近两个 tag"></a>获取最近两个 tag</h3><p>如果未输入两个 tag,则获取最近的两个 tag<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 获取最近提交的两个 tag</span><br><span class="line">function getAutoTag()&#123;</span><br><span class="line"><span class="meta">#</span> 根据日期排序获取所有tag</span><br><span class="line">current_git_tags=$(git tag --sort=taggerdate)</span><br><span class="line">for word in $&#123;current_git_tags&#125;</span><br><span class="line">do</span><br><span class="line">    tags[temp]=$&#123;word&#125;</span><br><span class="line">    ((++temp))</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span> 获取最近的两个 tag</span><br><span class="line">tag1=$&#123;tags[temp-2]&#125;</span><br><span class="line">tag2=$&#123;tags[temp-1]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取两个-tag-或者-commitId-之间所有的-message"><a href="#获取两个-tag-或者-commitId-之间所有的-message" class="headerlink" title="获取两个 tag 或者 commitId 之间所有的 message"></a>获取两个 tag 或者 commitId 之间所有的 message</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 获取两个 commitId 之间的 message</span><br><span class="line">function getInputCommitId()&#123;</span><br><span class="line">tag2=$&#123;input2&#125;</span><br><span class="line">tag1=$&#123;input1&#125;</span><br><span class="line"><span class="meta">#</span> 获取的 message 区间为[)</span><br><span class="line">git log --pretty=format:"%s" $&#123;tag2&#125;...$&#123;tag1&#125; &gt;commits.txt</span><br><span class="line"><span class="meta">#</span> 写入空格</span><br><span class="line">echo  &gt;&gt;commits.txt</span><br><span class="line"><span class="meta">#</span> 获取第二个输入 commitId 的 message</span><br><span class="line">git log --pretty=format:"%s" $&#123;tag1&#125; -1 &gt;&gt;commits.txt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取两个tag之间所有的 message</span><br><span class="line">function getTagMessages()&#123;</span><br><span class="line">getAutoTag</span><br><span class="line">echo $tag2  $tag1</span><br><span class="line">if [[ "" = $&#123;tag1&#125; ]]</span><br><span class="line">    then</span><br><span class="line"><span class="meta">#</span> 如果为获取到后提交的 tag,则获取先提交 tag 以前所有的 message,并写入到 commits.txt文件里</span><br><span class="line">    git log --pretty=format:"%s" $&#123;tag2&#125; &gt;commits.txt</span><br><span class="line">else</span><br><span class="line">git log --pretty=format:"%s" $&#123;tag2&#125;...$&#123;tag1&#125; &gt;commits.txt</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span> 将两个tag之间的所有commit message写入commits.txt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就获取了所有的 message并写入到了commits.txt文件中,现在需要做的就是清洗提交记录</p>
<h3 id="筛选符合规则的-message"><a href="#筛选符合规则的-message" class="headerlink" title="筛选符合规则的 message"></a>筛选符合规则的 message</h3><p>上一步我们把所有的 message 写入到了 commits 文件中去,这样我们就可以把文件读出来进行筛选,获得符合规范的 message<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 使用正则判断 commits.txt 每行开头是否符合我嗯的规则,并生成feat.txt和fix.txt</span><br><span class="line">function generateDoc()&#123;</span><br><span class="line">    # $1 代表方法 第一个入参数,方法参数为每行文本</span><br><span class="line">    if [[ "$1" =~ ^feat.*:$ ]]</span><br><span class="line">        then</span><br><span class="line">        # msg 代表 feat: 后所有的文本</span><br><span class="line">        msg="$&#123;@:2&#125;"</span><br><span class="line">        echo $&#123;msg&#125; &gt;&gt; feat.txt</span><br><span class="line">    elif [[ "$1" =~ ^fix.*:$ ]]</span><br><span class="line">        then</span><br><span class="line">        # msg 代表 fix: 后所有的文本</span><br><span class="line">        msg="$&#123;@:2&#125;"</span><br><span class="line">        echo $msg &gt;&gt; fix.txt</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 读取 commits.txt 每行文本</span><br><span class="line">while read line || [[ -n $&#123;line&#125; ]]</span><br><span class="line">do</span><br><span class="line">    message=$&#123;line&#125;</span><br><span class="line">    generateDoc $&#123;message&#125;</span><br><span class="line">done &lt; commits.txt</span><br><span class="line"><span class="meta">#</span> 删除 commits.txt</span><br><span class="line"><span class="meta">$</span>(rm -rf commits.txt)</span><br></pre></td></tr></table></figure></p>
<h3 id="合成-ChangeLog"><a href="#合成-ChangeLog" class="headerlink" title="合成 ChangeLog"></a>合成 ChangeLog</h3><p>通过分别读取 feat.txt 和 fix.txt 文件合成 ChangeLog<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 生成tag标题</span><br><span class="line"><span class="meta">#</span> inputType=2 代表使用 commitId 生成 log</span><br><span class="line">if [[ $&#123;inputType&#125; = "2" ]]</span><br><span class="line">    then</span><br><span class="line">    branch=$(git symbolic-ref --short -q HEAD)</span><br><span class="line">    time=$(git log --pretty=format:"%ai" $&#123;tag2&#125; -1)</span><br><span class="line">    echo "## $tag2 - $tag1 $branch ($time)" &gt;&gt;CHANGELOG.md</span><br><span class="line">else</span><br><span class="line"><span class="meta">#</span> 使用 tag 生成 log</span><br><span class="line">    time=$(git log -1 --format=%ai $&#123;tag2&#125;)</span><br><span class="line">    echo  "## $tag2 ($time)"&gt;&gt;CHANGELOG.md</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成Features行</span><br><span class="line">echo "### Features" &gt;&gt;CHANGELOG.md</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">    echo "* "$&#123;line&#125; &gt;&gt; CHANGELOG.md</span><br><span class="line">done &lt; feat.txt</span><br><span class="line"><span class="meta">$</span>(rm -rf feat.txt)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成Fixs行</span><br><span class="line">echo "### Fixs" &gt;&gt;CHANGELOG.md</span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 判断文件是否存在</span><br><span class="line">if [[ -f "./CHANGELOG.md" ]]</span><br><span class="line">then</span><br><span class="line">    echo CHANGELOG.md is exsit</span><br><span class="line">else</span><br><span class="line">    echo '# ChangeLog' &gt;CHANGELOG.md</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 读取 ChangeLog 文件,删除重复输入一直的内容,使用第一个输入的参数作为锚点对比</span><br><span class="line">while read text</span><br><span class="line">do</span><br><span class="line">    ((++i))</span><br><span class="line">    if [[ $&#123;text&#125; =~ "## $tag2" ]]</span><br><span class="line">        then</span><br><span class="line">        start=$i</span><br><span class="line">    elif [[ $tag1 != "" &amp;&amp; $&#123;text&#125; =~ "## $tag1" ]]</span><br><span class="line">        then</span><br><span class="line">        end=$i</span><br><span class="line">    fi</span><br><span class="line">done &lt; CHANGELOG.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> $&#123;start&#125; 为起始行</span><br><span class="line"><span class="meta">#</span> $&#123;end&#125; 为结束行</span><br><span class="line"></span><br><span class="line">if [[ "" = "$end" ]]</span><br><span class="line">    then</span><br><span class="line">    if [[ "" != "$start" ]]</span><br><span class="line">        then</span><br><span class="line">        # 如果没有结束行,则删除起始行以后所有的内容</span><br><span class="line">        $(sed -i "" "$start,\$d" CHANGELOG.md)</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    ((--end))</span><br><span class="line">    # 应换为插入</span><br><span class="line">    if [[ "$start" -gt "$end" ]]</span><br><span class="line">        then</span><br><span class="line">        $(sed -i "" "$start,\$d" CHANGELOG.md)</span><br><span class="line">    else</span><br><span class="line">    # 如果有结束行 则删除之间所有的内容</span><br><span class="line">        $(sed -i "" "$start,$&#123;end&#125;d" CHANGELOG.md)</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h1 id="集成工具"><a href="#集成工具" class="headerlink" title="集成工具"></a>集成工具</h1><p>因为需要提供 git template、检查 git message 是否符合规范和生成 CHANGELOG并且脚本都是在客户端,如果通过手动拷贝的方式分享给组内成员会很麻烦,并且后续更新也是很大的问题.所以通过 curl 和 wget 等命令,直接执行相应脚本,可以极大的方便接入脚本工具.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于自己也是初次接触 shell 可能写的不算好,边学边写完成了这个需求,shell 对于数据的处理还是很方便,可以做很多有意思的事情,提高开发效率.最近项目打算迁移 androidx,由于模块太多使用 AS 自带插件逐个升级,太麻烦所以肯定也需要通过脚本直接修改源码升级,正好也加强学习 shell.<br>本次只是实现了 Module 的 ChangeLog 生成,但是 App 的还未完成,目前考虑的方案有两种</p>
<ul>
<li>在生成脚本里把文件传到远程指定目录下,然后通过脚本提取所有 module 的文件,再重新生成 App 的 ChangeLog</li>
<li>通过脚本获取 App 的所有业务依赖,然后通过依赖再获取 git 地址,通过 git 地址下载到 module 的 ChangeLog,在重新生成 App 的 ChangeLog<br>两个方法个有好处吧,由于其他事情耽误目前还没开始做,方案记录下来有空实现.</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://ruby-china.org/topics/15737" target="_blank" rel="noopener">https://ruby-china.org/topics/15737</a></p>
<p><a href="https://juejin.im/post/5afc5242f265da0b7f44bee4" target="_blank" rel="noopener">https://juejin.im/post/5afc5242f265da0b7f44bee4</a></p>
<p><a href="https://commitlint.js.org/" target="_blank" rel="noopener">git message lint 工具</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative 中使用 @ReactMethod 和 @ReactProp 应注意的问题</title>
    <url>/2019/10/14/react-natvie-manager-abstractclass/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>公司项目中使用 React Native 实现部分功能,因为业务需求问题,比如 A 和 B 分别继承 ReactContextBaseJavaModule 且其 ReactMethod 所注解的方法也相同,但是其实现略有不同,这时候正常做法是会写抽象类或者说接口,这时候 ReactMethod 应该写在那里呢,如果在父类或者接口里,运行起来会发现找不到这个方法,如果写在实现类里会很麻烦.<br><a id="more"></a></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="实现类的方法里加-ReactMethod"><a href="#实现类的方法里加-ReactMethod" class="headerlink" title="实现类的方法里加 ReactMethod"></a>实现类的方法里加 ReactMethod</h5><p>这种方式就很麻烦不够优雅,但是可以立马解决问题.</p>
<h5 id="抽象类实现或者接口继承-ReactModuleWithSpec"><a href="#抽象类实现或者接口继承-ReactModuleWithSpec" class="headerlink" title="抽象类实现或者接口继承 ReactModuleWithSpec"></a>抽象类实现或者接口继承 ReactModuleWithSpec</h5><p>为什么直接在父类给方法加注解就不行呢,还是得从源码里找答案,直接搜索源码里处理注解的地方,如下所示:<br><figure class="highlight java"><figcaption><span>JavaModuleWrapper.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@DoNotStrip</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, <span class="string">"findMethods"</span>);</span><br><span class="line">    Set&lt;String&gt; methodNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends NativeModule&gt; classForMethods = mModuleClass;</span><br><span class="line">    <span class="comment">//获取父类</span></span><br><span class="line">    Class&lt;? extends NativeModule&gt; superClass =</span><br><span class="line">        (Class&lt;? extends NativeModule&gt;) mModuleClass.getSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (ReactModuleWithSpec<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">superClass</span>)) </span>&#123;</span><br><span class="line">        <span class="comment">//如果父类实现 ReactModuleWithSpec后,会获取父类的方法</span></span><br><span class="line">      classForMethods = superClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果父类没有实现 ReactModuleWithSpec,则会拿子类的方法,如果子类方法没有 ReactMethod 注解,则不会调用,这就解释了我们刚开始遇到的问题.</span></span><br><span class="line">    Method[] targetMethods = classForMethods.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method targetMethod : targetMethods) &#123;</span><br><span class="line">      ReactMethod annotation = targetMethod.getAnnotation(ReactMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//··· 忽略非重点代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据源码,我们就很清楚的理解所遇到的问题了.<strong>但是如果我们在实现类里做扩展,再加含有 ReactMethod 注解的方法时,我们运行时也会找不到此方法,所以使用时需要注意这一点</strong>.</p>
<h4 id="ReactProp-类似问题"><a href="#ReactProp-类似问题" class="headerlink" title="ReactProp 类似问题"></a>ReactProp 类似问题</h4><p>当我们在抽象类中对方法使用 ReactProp 注解时,运行时可以发现,他们时生效的.这个通过查看源码发现,其递归获取了父类,然后获取了方法.<br><figure class="highlight java"><figcaption><span>ViewManagersPropertyCache.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Map&lt;String, PropSetter&gt; <span class="title">getNativePropSettersForViewManagerClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;? extends ViewManager&gt; cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cls == ViewManager<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> EMPTY_PROPS_MAP;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, PropSetter&gt; props = CLASS_PROPS_CACHE.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (props != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归获取继承了 ViewManager 的类</span></span><br><span class="line">    props = <span class="keyword">new</span> HashMap&lt;&gt;(</span><br><span class="line">        getNativePropSettersForViewManagerClass(</span><br><span class="line">            (Class&lt;? extends ViewManager&gt;) cls.getSuperclass()));</span><br><span class="line">    extractPropSettersFromViewManagerClassDefinition(cls, props);</span><br><span class="line">    CLASS_PROPS_CACHE.put(cls, props);</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractPropSettersFromViewManagerClassDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;? extends ViewManager&gt; cls,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, PropSetter&gt; props)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取这个类的public,protroct,private方法,但不包括实现接口和父类的方法</span></span><br><span class="line">    Method[] declaredMethods = cls.getDeclaredMethods();</span><br><span class="line">    <span class="comment">//···省略无关代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 extractPropSettersFromViewManagerClassDefinition 这个方法,我们可以看出如果在<strong>接口中对方法使用 ReactProp 时会不生效</strong>.</p>
<p>遇到问题多看看源码实现,也许就会找到思路.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>你以为你懂得 Android (译)</title>
    <url>/2019/08/21/you-thought-you-knew-android/</url>
    <content><![CDATA[<h4 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h4><p>你知道 Android 里有个叫<code>blink</code>的 ViewGroup 吗?惊讶吗?我第一次知道它时和你是同样的表现.</p>
<p>当我正在阅读<a href="https://developer.android.com/reference/android/view/LayoutInflater" target="_blank" rel="noopener">LayoutInflater</a>的源码,我对 xml 如何转换成 object 特别感兴趣,所以我没有从头开始阅读这个类,而是直接阅读<code>inflate(layoutRes,parent</code>方法.</p>
<p>经过一段时间的阅读,我在<code>View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr)</code>方法前停了下来,这个方法签名没有特别之处,但是以下的情况很奇怪,并且注释也是.<br><img src="https://miro.medium.com/max/1400/1*4Nb8L6s0VJN5QrGO5RSgbw.png" alt><br><code>Let&#39;s party like it&#39;s 1995!</code><br><a id="more"></a><br>看起来很有意思,但是接下来这有趣就要被打破了,我们确切的知道它会发生什么.<strong>一个 ViewGroup 让 它的子 View 像节日灯一样的闪烁</strong>.但这 ViewGroup 的名字是什么呢?是<code>tag1995</code>吗?<br>不是的,<code>blink</code>才是这个 ViewGroup 的名字,不像 Android 里的<code>LinearLayout</code>或者<code>ReltaiveLayout</code>或任何其他的 ViewGroup 的布局后缀.那么它对任何 Android 开发者都大有用处吗?大部分不是的,但是知道有这样一个彩蛋是不错的🙂.<br>想看它的实际效果?如下所示<br><img src="https://miro.medium.com/max/3348/1*6dHMO7KqOUsW9pXbZ7E4Cw.png" alt="Usage in xml layout
"><br><img src="https://miro.medium.com/max/1200/1*QawR47hKULpQqtwyYJUbZw.gif" alt="Party!!!
"><br>在 Android Framework 源码里尝试发现彩蛋.不知道我能发现多少,如果我后面没有更多的文章可能就意味着没有了.像🤞这样交叉手指发现更多的彩蛋吧.<br>参考<br><a href="https://medium.com/u/c967b7e51f8b?source=post_page-----e46a556d0773----------------------" target="_blank" rel="noopener">Romain Guy</a> 向 Android  Framwork 里提交了<code>blink</code>布局源码.</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://medium.com/@anoopss/you-thought-you-knew-android-e46a556d0773" target="_blank" rel="noopener">原文地址</a><br><a href="https://android.googlesource.com/platform/frameworks/base/+/9c1223a71397b565f38015c07cae57a5015a6500%5E%21" target="_blank" rel="noopener">blink 源码</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij Plugin 开发(二)</title>
    <url>/2019/07/10/intellij-plugin-eventbus-2/</url>
    <content><![CDATA[<p>上一篇介绍怎样新建一个插件工程,本篇分析 EventBus 插件的实现.<br>此插件涉及较多的 Java GUI 代码,但是自己也不是很熟悉,只能做大概分析,重点在于分析扫描引用点.</p>
<h3 id="扫描规则"><a href="#扫描规则" class="headerlink" title="扫描规则"></a>扫描规则</h3><p>我们项目对于 EventBus 有特殊的封装,就需要插件可以扫描出<code>XXX.send(new NotifyEvent())</code>(XXX 类也可能会有子类),可以找出这个 Event 所有的接收点,并且对于继承了 Sender 的类页都应该支持.<br><figure class="highlight java"><figcaption><span>XXXX.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    send(<span class="keyword">new</span> NotifyEvent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object eventModel)</span> </span>&#123;</span><br><span class="line">      Smart.getEventBus().post(eventModel);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="判断发射点"><a href="#判断发射点" class="headerlink" title="判断发射点"></a>判断发射点</h4><p>当我们打开一个 java 文件时,就会框架就会调用 getLineMarkerInfo 方法去扫描当前类的每一行代码(这么说不恰当,应该是每个字段也包括空格、空行之类,所有的信息都会转化成 PsiElement),然后我们通过 PsiElement 去判断是否时符合我们的规则.例如判断 EventBus 发射点.<br><figure class="highlight java"><figcaption><span>PsiUtil.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEventBusPost</span><span class="params">(PsiElement psiElement)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断 psiElement 是否是方法(包括构造方法)的调用</span></span><br><span class="line">     <span class="keyword">if</span> (psiElement <span class="keyword">instanceof</span> PsiCallExpression) &#123;</span><br><span class="line">         PsiCallExpression callExpression = (PsiCallExpression) psiElement;</span><br><span class="line">         PsiMethod method = callExpression.resolveMethod();</span><br><span class="line">         <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">             String name = method.getName();</span><br><span class="line">             PsiElement parent = method.getParent();</span><br><span class="line">             <span class="comment">//判断方法名是否是发射点 我们的目标是 Smart.getEventBus().post() 和 XXXX.send() 和一些特殊形式</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="string">"post"</span>.equals(name) &amp;&amp; parent <span class="keyword">instanceof</span> PsiClass) &#123;</span><br><span class="line">                 PsiClass implClass = (PsiClass) parent;</span><br><span class="line">                 <span class="keyword">return</span> isEventBusClass(implClass) || isSuperClassEventBus(implClass);</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"send"</span>.equals(name) &amp;&amp; parent <span class="keyword">instanceof</span> PsiClass) &#123;</span><br><span class="line">                 PsiClass implClass = (PsiClass) parent;</span><br><span class="line">                 <span class="keyword">return</span> isEventSenderClass(implClass) || isSuperClassEventSender(implClass);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断类是否是我们自封装的类</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEventBusClass</span><span class="params">(PsiClass psiClass)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"SmartEventBus"</span>.equals(psiClass.getName());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断类是否是我们自封装类的子类</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSuperClassEventBus</span><span class="params">(PsiClass psiClass)</span> </span>&#123;</span><br><span class="line">     PsiClass[] supers = psiClass.getSupers();</span><br><span class="line">     <span class="keyword">if</span> (supers.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (PsiClass superClass : supers) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="string">"SmartEventBus"</span>.equals(superClass.getName())) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="判断接收点"><a href="#判断接收点" class="headerlink" title="判断接收点"></a>判断接收点</h4><p>判断符合我们规则的接收点<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEventBusReceiver</span><span class="params">(PsiElement psiElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (psiElement <span class="keyword">instanceof</span> PsiMethod) &#123;</span><br><span class="line">        PsiMethod method = (PsiMethod) psiElement;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        <span class="comment">//支持 EventBus 2.0 版本的 onEvent 和 onEventMainThread 两种接收点,且只有一个参数并且是 PsiClassType 类型,不至于造成对其他方法的误判</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"onEvent"</span>.equals(name) || <span class="string">"onEventMainThread"</span>.equals(name)) &amp;&amp; method.getParameterList().getParametersCount() == <span class="number">1</span> &amp;&amp; method.getParameterList().getParameters()[<span class="number">0</span>].getType() <span class="keyword">instanceof</span> PsiClassType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是针对我们项目关于扫描的自定义代码,通过这几个简单的规则就可以做到预期的效果.</p>
<h3 id="查找使用"><a href="#查找使用" class="headerlink" title="查找使用"></a>查找使用</h3><p><code>ShowUsagesAction</code>继承<code>AnAction</code>当我们点击 icon 后会执行<code>ShowUsagesAction.actionPerformed()</code>方法,在此处执行搜索全局代码、收集使用点、显示搜索框和提示框等,需要深入了解 intellij 源码.由于能力有限不敢做过多分析,具体代码可以查看<a href="https://github.com/kgmyshin/eventbus-intellij-plugin/blob/master/src/com/kgmyshin/ideaplugin/eventbus/ShowUsagesAction.java">ShowUsagesAction源码</a>.由于源码几乎没有注释,所以阅读起来有一定困难.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.jetbrains.org/intellij/sdk/docs/welcome.html" target="_blank" rel="noopener">IntelliJ Platform SDK</a><br><a href="https://github.com/kgmyshin/eventbus-intellij-plugin">eventbus-intellij-plugin</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Intellij Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij Plugin 开发(一)</title>
    <url>/2019/05/29/intellij-plugin-eventbus-1/</url>
    <content><![CDATA[<p>Intellij 有很多优秀的开源插件,让我们更加高效的编程.EventBus 虽然可以很好的解耦，但是对于使用者来说不那么方便找到发射点和接收点.EventBus Plugin 帮我们愉快的解决了这个痛点.但是由于我们项目自己封装 EventBus,所以其插件无法生效,只能通过站在巨人的肩膀上,修改轮子让他重新跑起来.</p>
<h3 id="配置开发环境-新建项目"><a href="#配置开发环境-新建项目" class="headerlink" title="配置开发环境 新建项目"></a>配置开发环境 新建项目</h3><p> 开发插件可以使用收费旗舰版也可是使用免费社区版本.</p>
<ol>
<li>File-&gt;New-&gt;Project 选择 Intellij Platform Plugin 如图<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/intellij-plguin-new.png" alt><br>Project SDK 选择 Intellij 的安装目录,这个 SDK 版本觉得这最低兼容版本,如果要适配低版本的 Intellij 或者 Android Stuido<br>如果想使用 Gradle Kotlin 之类的开发方式可以选择 Gradle 然后勾选 Java、Kotlin、Intellij Platform Plugin<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/intellij-plugin-new2.png" alt></li>
<li>输入项目名称和路径,点击 Finish 即可创建插件项目</li>
<li>配置 SandBox<br>IntelliJ Plugin Run/Debug模式运行在 SandBox 中进行的,和当前 Intellij 没什么关系,需要在 Project Structure 中设置 Sandbox Home 路径.<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/intellij-plugin-sandbox.png" alt><a id="more"></a>
</li>
</ol>
<h3 id="配置-plugin-xml"><a href="#配置-plugin-xml" class="headerlink" title="配置 plugin.xml"></a>配置 plugin.xml</h3><p>plugin.xml 就像是我们开发 Android 时的 AndroidMainfest.xml 文件,使用到的组件都必须在这里注册,否则就不会生效.<br><code>&lt;idea-version since-build=&quot;173.0&quot;/&gt;</code>这个表示插件支持的起始版本,根据<a href="http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html" target="_blank" rel="noopener">文档</a>可知是 2017.3 版本.<br><code>&lt;depends&gt;com.intellij.modules.lang&lt;/depends&gt;</code>是项目中用到的依赖插件<br><figure class="highlight xml"><figcaption><span>plugin.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">"com.intellij"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">codeInsight.lineMarkerProvider</span> <span class="attr">language</span>=<span class="string">"JAVA"</span></span></span><br><span class="line"><span class="tag">                                        <span class="attr">implementationClass</span>=<span class="string">"com.***.eventbus.EventBusLineMarkerProvider"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>extensions 定义插件的扩展类型,defaultExtensionNs 定义此项目是基于 Intellij Core 编写的插件,codeInsight.lineMarkerProvider 是一种扩展类型意为标记提示器,其实现的功能就是我们此次需要的,就像我们实现接口的方法后,实现类的方法前的图标,点击后会跳转到接口中.<br>经过这两个步骤就新建配置好了插件项目,我们就可以基于此实现我们的逻辑了.</p>
<h3 id="实现-LineMarkerProvider"><a href="#实现-LineMarkerProvider" class="headerlink" title="实现 LineMarkerProvider"></a>实现 LineMarkerProvider</h3><figure class="highlight java"><figcaption><span>LineMarkerProvider.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusLineMarkerProvider</span> <span class="keyword">implements</span> <span class="title">LineMarkerProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片资源应在 resources/icons 目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Icon ICON = IconLoader.getIcon(<span class="string">"/icons/icon.png"</span>);</span><br><span class="line">    <span class="comment">//最多查找应用数量 100 个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_USAGES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GutterIconNavigationHandler&lt;PsiElement&gt; SHOW_SENDERS =</span><br><span class="line">            (e, psiElement) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (psiElement <span class="keyword">instanceof</span> PsiMethod) &#123;</span><br><span class="line">                    Project project = psiElement.getProject();</span><br><span class="line">                    JavaPsiFacade javaPsiFacade = JavaPsiFacade.getInstance(project);</span><br><span class="line">                    <span class="comment">//查找 project 范围内 EventBus 的PsiClass</span></span><br><span class="line">                    PsiClass eventBusClass = javaPsiFacade.findClass(<span class="string">"com.***.event.EventBus"</span>, GlobalSearchScope.allScope(project));</span><br><span class="line">                    <span class="keyword">if</span> (eventBusClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//符合 EventBus 中 post() 方法</span></span><br><span class="line">                        PsiMethod postMethod = eventBusClass.findMethodsByName(<span class="string">"post"</span>, <span class="keyword">false</span>)[<span class="number">0</span>];</span><br><span class="line">                        PsiMethod method = (PsiMethod) psiElement;</span><br><span class="line"></span><br><span class="line">                        PsiClass eventClass = ((PsiClassType) method.getParameterList().getParameters()[<span class="number">0</span>].getTypeElement().getType()).resolve();</span><br><span class="line">                        ShowUsagesAction action = <span class="keyword">new</span> ShowUsagesAction(<span class="keyword">new</span> SenderFilter(eventClass));</span><br><span class="line">                        <span class="comment">//触发查找动作,弹框展示已经查找到的引用点</span></span><br><span class="line">                        action.startFindUsages(postMethod, <span class="keyword">new</span> RelativePoint(e), PsiUtilBase.findEditor(psiElement), MAX_USAGES);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GutterIconNavigationHandler&lt;PsiElement&gt; SHOW_RECEIVERS =</span><br><span class="line">            (e, psiElement) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (psiElement <span class="keyword">instanceof</span> PsiMethodCallExpression) &#123;</span><br><span class="line">                    PsiMethodCallExpression expression = (PsiMethodCallExpression) psiElement;</span><br><span class="line">                    PsiType[] expressionTypes = expression.getArgumentList().getExpressionTypes();</span><br><span class="line">                    <span class="keyword">if</span> (expressionTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        PsiClass eventClass = PsiUtils.getClass(expressionTypes[<span class="number">0</span>], psiElement);</span><br><span class="line">                        <span class="keyword">if</span> (eventClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            List&lt;PsiElement&gt; generatedDeclarations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                            generatedDeclarations.add(PsiUtils.getClass(expressionTypes[<span class="number">0</span>]));</span><br><span class="line">                            <span class="comment">//找到接收点接收对象的父类,这样通过发射点发射其子类,也可以看到其父类的接收点位置</span></span><br><span class="line">                            <span class="comment">//例如 Event2 extend Event ,EventBus.post(new Event2()) 那么可以在发射点同时看到 Event2 和 Event 的接收点位置</span></span><br><span class="line">                            <span class="keyword">for</span> (PsiType superType : expressionTypes[<span class="number">0</span>].getSuperTypes()) &#123;</span><br><span class="line">                                generatedDeclarations.add(PsiUtils.getClass(superType));</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">new</span> ShowUsagesAction(<span class="keyword">new</span> ReceiverFilter()).startFindUsages(generatedDeclarations, eventClass, <span class="keyword">new</span> RelativePoint(e), PsiUtilBase.findEditor(psiElement), MAX_USAGES);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LineMarkerInfo <span class="title">getLineMarkerInfo</span><span class="params">(@NotNull PsiElement psiElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PsiUtils.isEventBusPost(psiElement)) &#123;</span><br><span class="line">            <span class="comment">//判断是否是发射点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LineMarkerInfo&lt;&gt;(psiElement, psiElement.getTextRange(), ICON, Pass.UPDATE_ALL, <span class="keyword">null</span>, SHOW_RECEIVERS, GutterIconRenderer.Alignment.LEFT);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PsiUtils.isEventBusReceiver(psiElement)) &#123;</span><br><span class="line">            <span class="comment">//判断是否是接收点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LineMarkerInfo&lt;&gt;(psiElement, psiElement.getTextRange(), ICON, Pass.UPDATE_ALL, <span class="keyword">null</span>, SHOW_SENDERS, GutterIconRenderer.Alignment.LEFT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectSlowLineMarkers</span><span class="params">(@NotNull List&lt;PsiElement&gt; elements, @NotNull Collection&lt;LineMarkerInfo&gt; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LineMarkerProvider 会在我们每次打开文件时执行,当 getLineMarkerInfo 执行后一行代码如果符合我们的条件时,则行号后会出现 ICON 定义的代码,这个icon 必须是 <code>16 * 16</code> 或者 <code>32 * 32</code> 尺寸的图标.<br>PSI (Program Structure Interface)程序结构接口,可以描述文件的层次结构(所谓的PSI树),这样我们就可以针对代码,逐个进行匹配分析.这个相关文档很少,但是 Intellij 自带工具可以帮我们分析文件的 psi 树,点击 Tool-&gt;View PSI Structure of Current File 这样我们就可以直观的预览需要处理的文件.PSI 对于代码所有的关键字和标点都有定义,如下图里可以清楚的看出<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/intellij-plugin-psi.png" alt><br>通过这个工具和结合<a href="http://www.jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi_elements.html" target="_blank" rel="noopener">PsiElement 文档</a>可以学习怎么使用它.</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇只是介绍下怎么入门,简单的了解下怎么新建项目和基础的代码实现,由于相关文档比较少,如果想要编写实用的插件,就需要参考 GitHub 中大量的插件工程,通过学习可以更快入门.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Intellij Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android P 反射灰名单方法引起的问题</title>
    <url>/2019/03/17/android-p-invoke/</url>
    <content><![CDATA[<p><strong>本文中的灰名单指的是 Aandroid 规定的深灰名单</strong><br>我们应用使用了 <a href="https://github.com/whataa/pandora">Pandora 1.3.2 版本</a> 库,方便测试环境里查看界面元素、网络、数据库之类的数据.在使用 Aandroid 9.0 时发现会弹出下面这样的提示框.需要探寻下是什么原因引起的,在那里调用的,能不能去掉这个强制提示.<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/android_p_invoke.jpg" alt><br>应用的 targetSdkVersion 是 27,compileSdkVersion 是 28<br>Pandora 2.0 版本目前已经规避了这个问题,都使用了浅灰名单里的方法或字段.<br><a id="more"></a></p>
<h2 id="寻找问题"><a href="#寻找问题" class="headerlink" title="寻找问题"></a>寻找问题</h2><p>在打开 Pandora 之后,使用了其中一项功能发现 Logcat 中输出了<code>Accessing hidden field Landroid/view/ViewRootImpl;-&gt;mWindowAttributes:Landroid/view/WindowManager$LayoutParams; (dark greylist, reflection)</code>这段信息,应该是他反射调用了灰名单的字段,所以会有提示和弹框.<br>首先将这段提示复制到 AS 里通过全局搜索发现,是在 Activity 的 performStart 方法里调用了提示框<br><figure class="highlight java"><figcaption><span>Activity.java</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略了其他代码</span></span><br><span class="line">    <span class="comment">//白灰黑名单维护在系统,对系统应用不做限制</span></span><br><span class="line">    <span class="keyword">boolean</span> isApiWarningEnabled = SystemProperties.getInt(<span class="string">"ro.art.hiddenapi.warning"</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable || isApiWarningEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mMainThread.mHiddenApiWarningShown &amp;&amp; VMRuntime.getRuntime().hasUsedHiddenApi()) &#123;</span><br><span class="line">            <span class="comment">// 仅提示一次</span></span><br><span class="line">            mMainThread.mHiddenApiWarningShown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            String appName = getApplicationInfo().loadLabel(getPackageManager())</span><br><span class="line">                    .toString();</span><br><span class="line">            String warning = <span class="string">"Detected problems with API compatibility\n"</span></span><br><span class="line">                             + <span class="string">"(visit g.co/dev/appcompat for more info)"</span>;</span><br><span class="line">            <span class="keyword">if</span> (isAppDebuggable) &#123;</span><br><span class="line">                <span class="comment">//弹窗提示</span></span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">                    .setTitle(appName)</span><br><span class="line">                    .setMessage(warning)</span><br><span class="line">                    .setPositiveButton(android.R.string.ok, <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//竟然如此强制,生怕开发者不注意关闭</span></span><br><span class="line">                    .setCancelable(<span class="keyword">false</span>)</span><br><span class="line">                    .show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果非 debug 版本只 Toast 提示</span></span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, appName + <span class="string">"\n"</span> + warning, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看过源码知道了调用地点,那么只改变调用条件就可以将它不提示了.这个变量便是我们的突破口</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="targetSdkVersion-27"><a href="#targetSdkVersion-27" class="headerlink" title="targetSdkVersion 27"></a>targetSdkVersion 27</h3><ul>
<li>VMRuntime.getRuntime().hasUsedHiddenApi() 这个方法在AS里无法查看,但是在 Androidxref 查看后是个 Natvie 方法,反射修改起来困难有点大 </li>
<li>mMainThread.mHiddenApiWarningShown 这个变量很明显反射容易点,并且根据注释和源码得知,也就只在这里使用<br>查看源码这个变量来自于 ActivityThread 那么我们直接反射修改这个变量初始值即可.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         Class cls = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">         Method declaredMethod = cls.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">         declaredMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         Object activityThread = declaredMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">         Field mHiddenApiWarningShown = cls.getDeclaredField(<span class="string">"mHiddenApiWarningShown"</span>);</span><br><span class="line">         mHiddenApiWarningShown.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         mHiddenApiWarningShown.setBoolean(activityThread, <span class="keyword">true</span>);</span><br><span class="line">         Log.e(<span class="string">"reflection dark greylist is"</span>,<span class="string">"success"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         Log.e(<span class="string">"reflection dark greylist is"</span>,<span class="string">"fail"</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将反射修改变量方法放在 Application 初始化里便可以了.再也不用烦恼提示框的出现了.</p>
<h3 id="targetSdkVersion-28"><a href="#targetSdkVersion-28" class="headerlink" title="targetSdkVersion 28"></a>targetSdkVersion 28</h3><p>当在 targetSdkVersion 为28时,系统是不允许反射灰名单中的 API,如果使用则会抛出这个错误<code>java.lang.NoSuchFieldException: No field mWindowAttributes in class Landroid/view/ViewRootImpl; (declaration of &#39;android.view.ViewRootImpl&#39; appears in /system/framework/framework.jar!classes2.dex)</code>,而我们反射的 ActivityThread 类也在灰名单,这样就尴尬了陷入死循环里了.Google Play 对于 2019/5/1 以后上线的 APP 必须基于 28 版本开发,所以解决各种 hook 问题是很有必要和迫切的.<br>对于反射灰名单的字段或者方法都会抛出如下异常<img src="http://gityuan.com/images/hidden-api/hidden-api-exp.png" alt="hidden-api"></p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>但是天无绝人之路,万物皆可反射,有大佬给出了解决办法思路骚的不行,感觉自己真的思维限制了我的想象.通过<strong>以系统身份去反射</strong>拿到 API ,然后再去反射修改灰名单 API,这样系统就认为我们第二次修改的时候是系统类而豁免了检查.<a href="http://weishu.me/2019/03/16/another-free-reflection-above-android-p/" target="_blank" rel="noopener">另一种绕过 Android P以上非公开API限制的办法</a>,这个是大佬的博文,详细阐述了怎么解决这个问题,并且在 GitHub 开源了代码.鉴于 Android P 版本已经发布,所以这个方式很稳定,可以用于生产环境.而且在 Android Q beta 1 里测试也可以使用该方式.</p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>Pandora 2.0 版本更新后查看了下源码是怎么实现绕过灰名单检查机制的,然后也发现了很巧妙的做法,将 Class 的 classloader 置空,从而系统自动调用了 BootCalssLoader 去加载,即成功伪造成了系统方法去反射灰名单字段,绕过了检查机制,思路也是很棒.<a href="https://github.com/whataa/pandora/blob/master/pandora-core/src/main/java/tech/linjiang/pandora/util/Reflect28Util.java">Reflect28Util</a>这个是反射工具类,所有的反射都通过这个工具类进行操作.</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/whataa/pandora/blob/master/pandora-core/src/main/java/tech/linjiang/pandora/util/Reflect28Util.java">Pandora 绕过检查</a><br><a href="https://github.com/tiann/FreeReflection">FreeReflection</a><br><a href="http://weishu.me/2019/03/16/another-free-reflection-above-android-p/" target="_blank" rel="noopener">另一种绕过 Android P以上非公开API限制的办法</a><br><a href="http://weishu.me/2018/06/07/free-reflection-above-android-p/" target="_blank" rel="noopener">一种绕过Android P对非SDK接口限制的简单方法</a><br><a href="http://gityuan.com/2019/01/26/hidden_api/" target="_blank" rel="noopener">理解Android P内部API的限制调用机制</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本适配</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 9.0 Choreographer 原理解析</title>
    <url>/2019/03/15/choreographer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了监测 APP 运行时是否流畅,项目使用 Choreographer 配合 ActivityLifecycleCallbacks 监测页面掉帧情况,然后在记录到数据库,方便回顾那些页面出现频繁卡顿情况,目前只是在测试环境使用,还未实现上传至服务器做更直观的分析,都需要dump 出 db 文件再分析.项目最低版本也是 4.1 以上,所以使用了 Choreographer 这种方式.<br><a id="more"></a></p>
<h2 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h2><h3 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Choreographer choreographer = <span class="keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>获取当前线程的 Looper,而 Choreographer 我们是初始化在主线程,所以这里相当于是主线程,所以这样就是我们在使用 doFrame 时需要起一个子线程去打印 Log 和保存到数据库的原因.</p>
<h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法内代码有省略</span></span><br><span class="line">    <span class="comment">//FrameHandler 处理消息</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    <span class="comment">//接收 Native 方法的 VSYNC 信号</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//刷新间隔时间 也就是16.67ms  getRefreshRate()在 VirtualDisplayDevice 中定义为 60,也就是我们所说的默认刷新率</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">    <span class="comment">//创建回调对象队列 共有四种回调 所以初始化 size 为 4</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FrameHandler"><a href="#FrameHandler" class="headerlink" title="FrameHandler"></a>FrameHandler</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">//渲染帧</span></span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//请求 VSYNC</span></span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//请求回调</span></span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FrameDisplayEventReceiver"><a href="#FrameDisplayEventReceiver" class="headerlink" title="FrameDisplayEventReceiver"></a>FrameDisplayEventReceiver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//looper 此时也是主线程</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper, vsyncSource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统 native 方法会调用此方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//判断是否是主显示屏幕</span></span><br><span class="line">            <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Received vsync from secondary display, but we don't support "</span></span><br><span class="line">                        + <span class="string">"this case yet.  Choreographer needs a way to explicitly request "</span></span><br><span class="line">                        + <span class="string">"vsync for a specific display to ensure it doesn't lose track "</span></span><br><span class="line">                        + <span class="string">"of its scheduled vsync."</span>);</span><br><span class="line">                scheduleVsync();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修正时间确保时间顺序正确</span></span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Frame time is "</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                        + <span class="string">" ms in the future!  Check that graphics HAL is generating vsync "</span></span><br><span class="line">                        + <span class="string">"timestamps using the correct timebase."</span>);</span><br><span class="line">                timestampNanos = now;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                        + <span class="string">"one at a time."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mTimestampNanos = timestampNanos;</span><br><span class="line">            mFrame = frame;</span><br><span class="line">            <span class="comment">//向主线程发送异步消息处理下一帧 即调用 run()</span></span><br><span class="line">            Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">            doFrame(mTimestampNanos, mFrame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onVsync 向主线程发送<strong>异步消息</strong>时由于 FrameDisplayEventReceiver 实现了 Runnable 所以会直接调用其 run 方法</p>
<h3 id="doFrame"><a href="#doFrame" class="headerlink" title="doFrame"></a>doFrame</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法内有省略</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//如果为渲染完成,则直接返回,这样就渲染不了当前帧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原来帧的绘制时间点</span></span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="comment">//SKIPPED_FRAME_WARNING_LIMIT=30 如果页面复杂时,我们经常会看到 Log 里输出下面的信息,也就是说官方认为掉帧数=30时就认为太卡,建议优化了</span></span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                        + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Missed vsync by "</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">" ms "</span></span><br><span class="line">                        + <span class="string">"which is more than the frame interval of "</span></span><br><span class="line">                        + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">" ms!  "</span></span><br><span class="line">                        + <span class="string">"Skipping "</span> + skippedFrames + <span class="string">" frames and setting frame "</span></span><br><span class="line">                        + <span class="string">"time to "</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">" ms in the past."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Frame time appears to be going backwards.  May be due to a "</span></span><br><span class="line">                        + <span class="string">"previously skipped frame.  Waiting for next vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求 VSYNC</span></span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="comment">//优先处理输入事件</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> endNanos = System.nanoTime();</span><br><span class="line">        Log.d(TAG, <span class="string">"Frame "</span> + frame + <span class="string">": Finished, took "</span></span><br><span class="line">                + (endNanos - startNanos) * <span class="number">0.000001f</span> + <span class="string">" ms, latency "</span></span><br><span class="line">                + (startNanos - frameTimeNanos) * <span class="number">0.000001f</span> + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scheduleVsync"><a href="#scheduleVsync" class="headerlink" title="scheduleVsync"></a>scheduleVsync</h3><figure class="highlight java"><figcaption><span>scheduleVsyncLocked.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用了 FrameDisplayEventReceiver 父类 DisplayEventReceiver</span></span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>DisplayEventReceiver.java</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用了 Native 方法</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于请求 VSYNC 最终执行了 Native 方法,由于自己不熟悉所以先不深究做了什么,但是可以肯定,最终会执行 onVsync 方法.</p>
<h3 id="scheduleFrameLocked"><a href="#scheduleFrameLocked" class="headerlink" title="scheduleFrameLocked"></a>scheduleFrameLocked</h3><p>在 FrameHandler 收到 MSG_DO_SCHEDULE_CALLBACK 时调用 doScheduleCallback 方法,最终调用了 scheduleFrameLocked;<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                <span class="comment">//如果在当前Looper线程 则立即请求VSYNC</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则向主线程发送消息</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//只分析用户使用 VSYNC 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="doScheduleCallback"><a href="#doScheduleCallback" class="headerlink" title="doScheduleCallback"></a>doScheduleCallback</h3><p>在 FrameHandler 收到 MSG_DO_SCHEDULE_CALLBACK 时调用 doScheduleCallback(callbackType) 方法,根据回调队列获取当前时间的回调类型,最终调用了 scheduleFrameLocked 方法;</p>
<h3 id="doCallbacks"><a href="#doCallbacks" class="headerlink" title="doCallbacks"></a>doCallbacks</h3><p>doFrame 方法里在最后调用了四种类型的 callback<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//动画类型</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//遍历类型 其他异步消息处理完之后,处理执行 layout 和 draw</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//提交类型 在 traversal完成后 处理 post-draw 操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_COMMIT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = now - frameTimeNanos;</span><br><span class="line">            Trace.traceCounter(Trace.TRACE_TAG_VIEW, <span class="string">"jitterNanos"</span>, (<span class="keyword">int</span>) jitterNanos);</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Commit callback delayed by "</span> + (jitterNanos * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">" ms which is more than twice the frame interval of "</span></span><br><span class="line">                            + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">" ms!  "</span></span><br><span class="line">                            + <span class="string">"Setting frame time to "</span> + (lastFrameOffset * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">" ms in the past."</span>);</span><br><span class="line">                    mDebugPrintNextFrameTimeDelta = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"RunCallback: type="</span> + callbackType</span><br><span class="line">                        + <span class="string">", action="</span> + c.action + <span class="string">", token="</span> + c.token</span><br><span class="line">                        + <span class="string">", latencyMillis="</span> + (SystemClock.uptimeMillis() - c.dueTime));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果token=FRAME_CALLBACK_TOKEN,则调用下一个回调的 doFrame 否则继续调用 run</span></span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">                recycleCallbackLocked(callbacks);</span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CallbackRecord"><a href="#CallbackRecord" class="headerlink" title="CallbackRecord"></a>CallbackRecord</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">    <span class="comment">//Runnable 类型 或者 FrameCallback类型</span></span><br><span class="line">    <span class="keyword">public</span> Object action;</span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行输入、动画或者遍历的 Runnalbe 2.8节有阐述</span></span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CallbackQueue"><a href="#CallbackQueue" class="headerlink" title="CallbackQueue"></a>CallbackQueue</h3><figure class="highlight java"><figcaption><span>CallbackQueue.addCallbackLocked</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallbackLocked</span><span class="params">(<span class="keyword">long</span> dueTime, Object action, Object token)</span> </span>&#123;</span><br><span class="line">           CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);</span><br><span class="line">           CallbackRecord entry = mHead;</span><br><span class="line">           <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mHead = callback;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//按照时间降序入队</span></span><br><span class="line">           <span class="keyword">if</span> (dueTime &lt; entry.dueTime) &#123;</span><br><span class="line">               callback.next = entry;</span><br><span class="line">               mHead = callback;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (dueTime &lt; entry.next.dueTime) &#123;</span><br><span class="line">                   callback.next = entry.next;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               entry = entry.next;</span><br><span class="line">           &#125;</span><br><span class="line">           entry.next = callback;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>CallbackQueue 是一个由 CallbackRecord 构成的单向链表,把 CallbackRecord 按照事件发生顺序插入到队列中,在 doFrame 方法中可以看出最先放入 input 回调,这样也保证输入事件最先执行,这样也正好对应到<code>ViewRootImpl</code>中<code>ConsumeBatchedInputRunnable InvalidateOnAnimationRunnable TraversalRunnable</code>他们三个分别对应了三种回调类型的 Runnalbe.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ViewRootImpl 中初始化 Choreographer 后则通过调用上面这个方法,执行不同的事件类型.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过查看源码知道整个屏幕刷新机制,平时看到 Log 里打印<code>The application may be doing too much work on its main thread</code>也知道了出处.也知道了经常使用的 requestLayout 其实最终其实执行的是 ViewRootImpl 的 TraversalRunnable,对于卡顿的形成也稍微有点了解.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c2d93861095a" target="_blank" rel="noopener">Android8.1 Choreographer机制与源码分析</a><br><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">Choreographer原理</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Camera Api 拍摄身份证</title>
    <url>/2019/02/27/camera-id-card/</url>
    <content><![CDATA[<p>项目中需要核验身份信息,所以模拟支付宝的身份证 OCR 界面,做一个类似的功能.但是又有不同的地方,我们需要拍下照片而不是不断的扫描获取图像.<br>由于项目最低支持 4.0 系统为了方便起见使用 Camera 而不是 Camera2 接口,因为 Camera2 是 5.0 以后加入的 api.<br><a id="more"></a></p>
<h3 id="请求相机权限"><a href="#请求相机权限" class="headerlink" title="请求相机权限"></a>请求相机权限</h3><p>打开相机需要<code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code>权限,并且相机权限也是运行时权限,需要在打开相机前动态请求.</p>
<h3 id="请求存储权限"><a href="#请求存储权限" class="headerlink" title="请求存储权限"></a>请求存储权限</h3><p>因为 sample 中使用了 cache 目录,所以不需要请求存储权限,如果使用外部存储,则需要请求运行时权限.</p>
<h3 id="调用相机接口"><a href="#调用相机接口" class="headerlink" title="调用相机接口"></a>调用相机接口</h3><ol>
<li>创建预览界面，使用 SurfaceView 绘制实时预览图像,现在推荐使用 TextureView,关于两者的特性和区别不再赘述,文末有参考文章,<br>由于相机镜头是横向的,所以需要设置相机预览为竖屏<code>camera.setDisplayOrientation(90);</code>,在拍照页面退出时也需要及时释放相机资源.</li>
<li><strong>调整预览尺寸、调整图片尺寸</strong> 这个是拍照关键<br>我们所要实现的功能是全屏预览,相机预览尺寸是从它所支持的规格里面选择,而不是我们自身决定,而不同手机又有不同屏幕的比例,所以我们需要在手机预览尺寸匹配到一个最相近的尺寸,设置为相机的预览尺寸.<br>匹配算法:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Point <span class="title">machBestSize</span><span class="params">(Camera.Parameters parameters, Point screenResolution, List&lt;Camera.Size&gt; supportedSizes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//降序排列</span></span><br><span class="line">        List&lt;Camera.Size&gt; supportedPreviewSizes = <span class="keyword">new</span> ArrayList&lt;Camera.Size&gt;(supportedSizes);</span><br><span class="line">        Collections.sort(supportedPreviewSizes, <span class="keyword">new</span> Comparator&lt;Camera.Size&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Camera.Size a, Camera.Size b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> aPixels = a.height * a.width;</span><br><span class="line">                <span class="keyword">int</span> bPixels = b.height * b.width;</span><br><span class="line">                <span class="keyword">if</span> (bPixels &lt; aPixels) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bPixels &gt; aPixels) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//打印镜头支持的预览尺寸</span></span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.INFO)) &#123;</span><br><span class="line">            StringBuilder previewSizesString = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (Camera.Size supportedPreviewSize : supportedPreviewSizes) &#123;</span><br><span class="line">                previewSizesString.append(supportedPreviewSize.width).append(<span class="string">'x'</span>).append(supportedPreviewSize.height).append(<span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">"Supported preview sizes: "</span> + previewSizesString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> screenAspectRatio = (<span class="keyword">double</span>) screenResolution.x / (<span class="keyword">double</span>) screenResolution.y;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Camera.Size&gt; it = supportedPreviewSizes.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Camera.Size supportedPreviewSize = it.next();</span><br><span class="line">            <span class="keyword">int</span> realWidth = supportedPreviewSize.width;</span><br><span class="line">            <span class="keyword">int</span> realHeight = supportedPreviewSize.height;</span><br><span class="line">            <span class="comment">//MIN_PREVIEW_PIXELS = 480 * 320 移除过小的尺寸</span></span><br><span class="line">            <span class="keyword">if</span> (realWidth * realHeight &lt; MIN_PREVIEW_PIXELS) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isCandidatePortrait = realWidth &lt; realHeight;</span><br><span class="line">            <span class="keyword">int</span> maybeFlippedWidth = isCandidatePortrait ? realHeight : realWidth;</span><br><span class="line">            <span class="keyword">int</span> maybeFlippedHeight = isCandidatePortrait ? realWidth : realHeight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> aspectRatio = (<span class="keyword">double</span>) maybeFlippedWidth / (<span class="keyword">double</span>) maybeFlippedHeight;</span><br><span class="line">            <span class="keyword">double</span> distortion = Math.abs(aspectRatio - screenAspectRatio);</span><br><span class="line">            <span class="comment">// MAX_ASPECT_DISTORTION = 1.5 异常纵横比偏差过大的尺寸</span></span><br><span class="line">            <span class="keyword">if</span> (distortion &gt; MAX_ASPECT_DISTORTION) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maybeFlippedWidth == screenResolution.x &amp;&amp; maybeFlippedHeight == screenResolution.y) &#123;</span><br><span class="line">                Point exactPoint = <span class="keyword">new</span> Point(realWidth, realHeight);</span><br><span class="line">                Log.i(TAG, <span class="string">"Found preview size exactly matching screen size: "</span> + exactPoint);</span><br><span class="line">                <span class="keyword">return</span> exactPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在没有匹配到最优结果情况下的兜底策略</span></span><br><span class="line">        <span class="keyword">if</span> (!supportedPreviewSizes.isEmpty()) &#123;</span><br><span class="line">            Camera.Size largestPreview = supportedPreviewSizes.get(<span class="number">0</span>);</span><br><span class="line">            Point largestSize = <span class="keyword">new</span> Point(largestPreview.width, largestPreview.height);</span><br><span class="line">            Log.i(TAG, <span class="string">"Using largest suitable preview size: "</span> + largestSize);</span><br><span class="line">            <span class="keyword">return</span> largestSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在没有获取预览尺寸列表下的兜底策略</span></span><br><span class="line">        Camera.Size defaultPreview = parameters.getPictureSize();</span><br><span class="line">        Point defaultSize = <span class="keyword">new</span> Point(defaultPreview.width, defaultPreview.height);</span><br><span class="line">        Log.i(TAG, <span class="string">"No suitable preview sizes, using default: "</span> + defaultSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> defaultSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过这个算法我们就可以匹配到相近的相机预览尺寸,但是还必须匹配拍照尺寸,因为预览尺寸和照片尺寸是两个不同的逻辑,如果只匹配到预览尺寸,有的手机会匹配到一个过小的照片尺寸,这样就无法看清图片信息.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point pictureSize = findBestPictureSizeValue(parameters, cameraResolution);</span><br><span class="line"><span class="comment">//设置拍照尺寸</span></span><br><span class="line">parameters.setPictureSize(pictureSize.x, pictureSize.y);</span><br><span class="line">camera.setParameters(parameters);</span><br></pre></td></tr></table></figure></p>
<p>这样就可以和手机自带的相机全屏模式下预览效果一样了</p>
<h3 id="拍照、剪裁、压缩、保存"><a href="#拍照、剪裁、压缩、保存" class="headerlink" title="拍照、剪裁、压缩、保存"></a>拍照、剪裁、压缩、保存</h3><p>为了方便OCR,所以我们将图片进行剪裁至身份证大小,对于过大的尺寸压缩至复合我们要求,保存成文件方便上传至服务器.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拍照</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val camera = cameraManager.camera</span><br><span class="line">    <span class="comment">//只需要获取 jpeg 格式图片</span></span><br><span class="line">    camera.takePicture(<span class="keyword">null</span>, <span class="keyword">null</span>, Camera.PictureCallback &#123; data, _ -&gt;</span><br><span class="line">        <span class="keyword">var</span> resource = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.size)</span><br><span class="line">        <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="meta">@CameraActivity</span>, <span class="string">"拍照失败"</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (canCrop) &#123;</span><br><span class="line">                <span class="comment">//剪裁图片至身份证大小</span></span><br><span class="line">                resource = cropImage(resource)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保存图片至文件</span></span><br><span class="line">            val path = saveBitmap(resource)</span><br><span class="line">            <span class="keyword">if</span> (path.isNotEmpty()) &#123;</span><br><span class="line">                Log.e(<span class="string">"photo saved in path:"</span>, path)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span><span class="meta">@CameraActivity</span>, <span class="string">"照片保存失败"</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">            val intent = Intent()</span><br><span class="line">            intent.putExtra(<span class="string">"imagePath"</span>, path)</span><br><span class="line">            setResult(Activity.RESULT_OK, intent)</span><br><span class="line">            finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪裁图片 通过计算身份证框与屏幕的距离 确定图片剪裁的范围</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">cropImage</span><span class="params">(resource: Bitmap)</span>: Bitmap </span>&#123;</span><br><span class="line">    val ratio = resource.width / (height * <span class="number">1.0</span>)</span><br><span class="line">    val pictureWidth = dp2px(<span class="number">450</span>) * ratio</span><br><span class="line">    val pictureHeight = dp2px(<span class="number">282</span>) * ratio</span><br><span class="line">    val x = (resource.width - pictureWidth) / <span class="number">2</span></span><br><span class="line">    val y = (resource.height - pictureHeight) / <span class="number">2</span></span><br><span class="line">    val bitmap = Bitmap.createBitmap(resource, x.toInt(), y.toInt(),pictureWidth.toInt(), pictureHeight.toInt())</span><br><span class="line">    <span class="keyword">if</span> (pictureWidth &gt; maxWidth) &#123;</span><br><span class="line">        val originRatio = (pictureWidth / (pictureHeight * <span class="number">1.0</span>)).toFloat()</span><br><span class="line">        val matrix = Matrix()</span><br><span class="line">        matrix.postScale(originRatio, originRatio)</span><br><span class="line">        <span class="keyword">return</span> Bitmap.createScaledBitmap(bitmap, maxWidth, (maxWidth /originRatio).toInt(), <span class="keyword">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitmap</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存图片至缓存目录,不需要请求存储权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">saveBitmap</span><span class="params">(resource: Bitmap)</span>: String </span>&#123;</span><br><span class="line">    val picturePathName = cacheDir.absolutePath + File.separator +System.currentTimeMillis() + <span class="string">".jpg"</span></span><br><span class="line">    val file = File(picturePathName)</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> isSuccess = <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        val fos = FileOutputStream(file)</span><br><span class="line">        isSuccess = resource.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, fos)</span><br><span class="line">        fos.flush()</span><br><span class="line">        fos.close()</span><br><span class="line">        result = file.absolutePath</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (isSuccess) result <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有的手机相机存在预览时画面稍微变形,在相机里用全屏预览时也发现有同样的问题,应该是预览比例和屏幕比例有差别导致的.如果想要预览效果完美匹配,则需要改变预览尺寸而不是固定为屏幕尺寸大小.</p>
<h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>拍摄国徽页效果图(sample 效果) 如果为人像页则有人像框 <strong>国徽页为正面 人像页为反面</strong><br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/camera_id_card_front.png" alt></p>
<h3 id="更新兼容性方案"><a href="#更新兼容性方案" class="headerlink" title="更新兼容性方案"></a>更新兼容性方案</h3><p>经过线上验证存在匹配照片尺寸小于身份证尺寸的问题,导致拍出的图片太小模糊问题.<br>所以启用备用方案,点击拍照时直接通过<code>setOneShotPreviewCallback</code>实时预览回调获取图片数组,然后将数组转化为 Bitmap 供调用方使用.<br>这里需要注意的是 <code>onPreviewFrame</code>里返回的数组是<code>YUV420SP 格式</code>,不能直接通过<code>BitmapFactory</code>生成图片,需要用<code>YuvImage</code>进行转化才可以使用.<br><figure class="highlight java"><figcaption><span>生成 Bitmap</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">generateBitmap</span><span class="params">(camera: Camera, data: ByteArray)</span>: Bitmap? </span>&#123;</span><br><span class="line">        val size = camera.parameters.previewSize</span><br><span class="line">        val w = size.width </span><br><span class="line">        val h = size.height</span><br><span class="line">        val image = YuvImage(data, ImageFormat.NV21,</span><br><span class="line">                w, h, <span class="keyword">null</span>)</span><br><span class="line">        val os = ByteArrayOutputStream()</span><br><span class="line">        <span class="keyword">if</span> (!image.compressToJpeg(Rect(<span class="number">0</span>, <span class="number">0</span>, w, h), <span class="number">100</span>, os)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        val tmp = os.toByteArray()</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeByteArray(tmp, <span class="number">0</span>, tmp.size, BitmapFactory.Options())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其他逻辑都不用改变,这种方法通过界面上的所见即所得直接获取图片,以减少适配问题.</p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/Thewhitelight/Tinder/tree/master/camera">GitHub camera module为此 sample</a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/jinzhuojun/article/details/44062175" target="_blank" rel="noopener">Android 5.0(Lollipop)中的SurfaceTexture，TextureView, SurfaceView和GLSurfaceView</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title>应用安装版本适配问题</title>
    <url>/2019/02/21/install_apk_refer/</url>
    <content><![CDATA[<p>使用 DownloadManger 进行应用内更新然后当下载成功时调起安装界面,感觉挺简单调用系统 api 就可以完成,但是里面适配的坑真的是很多.<br><a id="more"></a></p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="6-0以下"><a href="#6-0以下" class="headerlink" title="6.0以下"></a>6.0以下</h3><p>几乎没什么坑按照常规代码的下载安装即可<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//downloadId 使用 DownloadManager 时指定的 id</span></span><br><span class="line">Uri uri = downloadManager.getUriForDownloadedFile(downloadId);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setDataAndType(uri, <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">mContext.startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<h3 id="6-0"><a href="#6-0" class="headerlink" title="6.0"></a>6.0</h3><div class="note info">
            <p>首先要申请运行时读写权限 </p>
          </div>
获得授权后,如果使用上述代码打开安装页面则会抛出下面的错误
<div class="note danger">
            <p>Caused by: android.content.ActivityNotFoundException: No Activity found to handle Intent { act=android.intent.action.VIEW dat=content: typ=application/vnd.android.package-archive flg=0x10000000 } </p>
          </div>
<p>应为在 6.0 中 <code>downloadManager.getUriForDownloadedFile(downloadId)</code> 获取的 uri 为 content://downloads/my_downloads/109 这种格式,显然这不是个文件地址路径导致上面的报错*,<strong>但这个问题只存在于 6.0</strong>,所以需要针对 6.0 版本进行判断处理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION_CODES.M == Build.VERSION.SDK_INT) &#123;</span><br><span class="line">           DownloadManager dManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE);</span><br><span class="line">           DownloadManager.Query query = <span class="keyword">new</span> DownloadManager.Query().setFilterById(downloadId);</span><br><span class="line">           Cursor c = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (dManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">               c = dManager.query(query);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (c.moveToFirst()) &#123;</span><br><span class="line">                   <span class="keyword">int</span> columnIndex = c.getColumnIndex(DownloadManager.COLUMN_STATUS);</span><br><span class="line">                   <span class="keyword">if</span> (DownloadManager.STATUS_SUCCESSFUL == c.getInt(columnIndex)) &#123;</span><br><span class="line">                       String downloadFileUrl = c.getString(c.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));</span><br><span class="line">                       <span class="comment">//获取 apk 地址安装</span></span><br><span class="line">                       installAPK(Uri.parse(downloadFileUrl));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Uri downloadFileUri = downloadManager.getUriForDownloadedFile(downloadId);</span><br><span class="line">           installAPK(downloadFileUri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取 apk 地址后便可以进行安装</p>
<h3 id="7-0"><a href="#7-0" class="headerlink" title="7.0"></a>7.0</h3><div class="note info">
            <p>对于面向 Android 7.0 的应用,Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 </p>
          </div>
<p>具体做法 可以参考 <a href="http://yifeng.studio/2017/05/03/android-7-0-compat-fileprovider/" target="_blank" rel="noopener">关于 Android 7.0 适配中 FileProvider 部分的总结</a></p>
<h3 id="8-0以上"><a href="#8-0以上" class="headerlink" title="8.0以上"></a>8.0以上</h3><p>由于权限变更 需要在 AndroidManifest.xml 加入<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.REQUEST_INSTALL_PACKAGES"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>否则会 RuntimeExcetption<br>在 GitHub 中看到有人反映,在 Android 8.0 Oreo 中,Google 移除掉了容易被滥用的“允许位置来源”应用的开关,在安装 Play Store 之外的第三方来源的 Android 应用的时候,竟然没有了“允许未知来源”的检查框,但是我手上的 8.1 和 9.0 系统则都有这个提示框. 但是不能排除有手机没有或者用户关闭过,所以还是加入权限判断及申请会比较好,这个 issues 正好提供了解决方案<br><a href="https://github.com/yjfnypeu/UpdatePlugin/issues/51">申请“允许位置来源”</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://yifeng.studio/2017/05/03/android-7-0-compat-fileprovider/" target="_blank" rel="noopener">关于 Android 7.0 适配中 FileProvider 部分的总结</a><br><a href="https://github.com/yjfnypeu/UpdatePlugin/issues/51">申请“允许位置来源”</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本适配</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 AOP 对方法添加监控日志</title>
    <url>/2019/01/02/android-track-log/</url>
    <content><![CDATA[<p>在查看同事写的代码时,发现各种方法调用有点混乱,不易快速梳理逻辑.所以想着是否可以通过打印方法日志,从而观察各种方法间的调用逻辑.</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol>
<li>打印方法名称、入参、耗时、返回值</li>
<li>对项目所有方法生效</li>
<li>可以自定义排除不打印的类</li>
<li>可作为三方库<a id="more"></a>
</li>
</ol>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>本项目使用 Javassist 实现了以下需求.</p>
<h5 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h5><p>这个功能让我想起了 JakeWharton 大神的 hugo 库,通过 AspectJ 对添加注解的方法插入 Log 在调用的时候就可以观察调用顺序及参数.但是这个库不能满足所有方法的打印,只能对添加了注解的方法打印,手动给方法添加注解工程量太大.但是可以通过改造切入点<code>@Pointcut(&quot;execution(* &quot; + BuildConfig.PACKAGE_NAME + &quot;..*.*(..))  BuildConfig.PACKAGE_NAME 为项目包名</code> 使其切入包内所有方法,这样便可以打印所有方法,但是这样又不能满足作为第三方库的问题,因为注解值必须是静态常量,不能动态修改.本项目借鉴了 hugo 库部分思想.在<a href="https://github.com/Thewhitelight/Analysis">Github</a> 中有使用 AspectJ 实现部分需求,并且可以切入 Kotlin.<br>Aspectj 本身语法很简单,应该是最容易上手的 AOP 框架,但是对 Kotlin 支持有问题,关于这个可以参考沪江网校对 AspectJ 改造的开源项目,其支持了更多功能,文后参考中有给出相关链接.</p>
<h5 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h5><p>Javassist 是一个开源的分析、编辑和创建 Java 字节码 的类库 .性能较 ASM 差,跟 cglib 差不多,但是使用相对简单.<br>为了方便引用所以采用 gradle plugin 方式,方便调用者快速添加到原有项目中去.关于编写插件的教程网络有很多,不做过多介绍.</p>
<h6 id="TraceExtension-自定义-plugin-配置"><a href="#TraceExtension-自定义-plugin-配置" class="headerlink" title="TraceExtension 自定义 plugin 配置"></a>TraceExtension 自定义 plugin 配置</h6><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceExtension</span> &#123;</span></span><br><span class="line">    <span class="comment">//需要排除的类</span></span><br><span class="line">    List&lt;String&gt; classExcludes = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">    <span class="comment">//需要排除的包</span></span><br><span class="line">    List&lt;String&gt; packageExcludes = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">    <span class="comment">//是否启用</span></span><br><span class="line">    <span class="keyword">def</span> enabled = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//项目包名,并非applicationId</span></span><br><span class="line">    <span class="keyword">def</span> packageName</span><br><span class="line">    <span class="comment">//打印日志的级别</span></span><br><span class="line">    <span class="keyword">def</span> logLevel = <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TraceExtension 定义自定义配置类,方便排除一些简单的工具类调用.</p>
<h6 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h6><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trace</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> hasApp = project.plugins.withType(AppPlugin)</span><br><span class="line">        <span class="keyword">def</span> hasLib = project.plugins.withType(LibraryPlugin)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasApp &amp;&amp; !hasLib) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"'android' or 'android-library' plugin required."</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">def</span> variants</span><br><span class="line">        <span class="keyword">if</span> (hasApp) &#123;</span><br><span class="line">            variants = project.android.applicationVariants</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            variants = project.android.libraryVariants</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">def</span> log = project.logger</span><br><span class="line">        variants.all &#123; variant -&gt;</span><br><span class="line">            <span class="keyword">if</span> (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Skipping non-debuggable build type '$&#123;variant.buildType.name&#125;'."</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!project.Trace.enabled) &#123;</span><br><span class="line">                log.debug(<span class="string">"Trace is not disabled."</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        project.extensions.create(<span class="string">'Trace'</span>, TraceExtension)</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"=== Trace Plugin ==="</span>)</span><br><span class="line">        <span class="keyword">def</span> android = project.extensions.findByType(AppExtension)</span><br><span class="line">        <span class="comment">//注册 Transform,注入所要插入的代码</span></span><br><span class="line">        android.registerTransform(<span class="keyword">new</span> TraceTransform(project))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Trace 为自定义的插件,在 release 环境下不需要插入 Log 以免影响性能.</p>
<h6 id="TraceTransform"><a href="#TraceTransform" class="headerlink" title="TraceTransform"></a>TraceTransform</h6><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Project project</span><br><span class="line"></span><br><span class="line">    TraceTransform(Project project) &#123;</span><br><span class="line">        <span class="keyword">this</span>.project = project</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TraceTransform"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要处理的数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要处理的范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        // 宿主项目、其子项目及外部引用库</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line">        if (!project.Trace.enabled) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        def outputProvider = transformInvocation.outputProvider</span><br><span class="line"></span><br><span class="line">        transformInvocation.inputs.each &#123; TransformInput input -&gt;</span><br><span class="line">            //宿主项目</span><br><span class="line">            input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">                //注入代码</span><br><span class="line">                TraceInject.injectDirCode(directoryInput.file.absolutePath, project)</span><br><span class="line">                def dest = outputProvider.getContentLocation(</span><br><span class="line">                        directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes,</span><br><span class="line">                        directoryInput.scopes,</span><br><span class="line">                        Format.DIRECTORY)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //第三方jar 虽然对jar没有操作,但是也要输出到out路径 不然运行时会抛错.</span><br><span class="line">            input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">                def jarName = jarInput.name</span><br><span class="line">                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">                if (jarName.endsWith(".jar")) &#123;</span><br><span class="line">                    jarName = jarName.substring(0, jarName.length() - 4)</span><br><span class="line">                &#125;</span><br><span class="line">                def dest = outputProvider.getContentLocation(</span><br><span class="line">                        jarName + md5Name,</span><br><span class="line">                        jarInput.contentTypes,</span><br><span class="line">                        jarInput.scopes,</span><br><span class="line">                        Format.JAR)</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为了在方法中添加 Log 就需要赶在 class 文件被转化为 dex 文件之前去修改类,Tranfrom 注册到插件中便会自动添加到 Task 执行序列中，并且正好是项目被打包成dex之前,不需要像 AspectJ 那用手动添加到最后一个 Task 中去.</p>
<h6 id="TraceInject-插入-Log"><a href="#TraceInject-插入-Log" class="headerlink" title="TraceInject 插入 Log"></a>TraceInject 插入 Log</h6><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceInject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String TAG = <span class="string">"Trace"</span></span><br><span class="line">    <span class="keyword">static</span> ClassPool POOL = ClassPool.getDefault()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> injectDirCode(String path, Project project) &#123;</span><br><span class="line">        POOL.appendClassPath(path)</span><br><span class="line">        <span class="comment">//添加 Android SDK 路径</span></span><br><span class="line">        POOL.appendClassPath(project.android.bootClasspath[<span class="number">0</span>].toString())</span><br><span class="line">        File dir = <span class="keyword">new</span> File(path)</span><br><span class="line">        <span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">            dir.eachFileRecurse &#123; File file -&gt;</span><br><span class="line">                String filePath = file.absolutePath</span><br><span class="line">                <span class="comment">//排除不需要的系统生成class</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">".class"</span>)</span><br><span class="line">                        &amp;&amp; !filePath.contains(<span class="string">'R$'</span>)</span><br><span class="line">                        &amp;&amp; !filePath.contains(<span class="string">'R.class'</span>)</span><br><span class="line">                        &amp;&amp; !filePath.contains(<span class="string">"BuildConfig.class"</span>)) &#123;</span><br><span class="line">                    modifyClass(project, path, filePath)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> modifyClass(Project project, String path, String filePath) &#123;</span><br><span class="line">        String classPath</span><br><span class="line">        <span class="keyword">def</span> packageName = project.Trace.packageName</span><br><span class="line">        filePath = filePath.replace(<span class="string">"/"</span>, <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classExcludes(project, filePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (packageExcludes(project, filePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filePath.contains(packageName)) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = filePath.indexOf(packageName)</span><br><span class="line">            classPath = filePath.substring(index, filePath.length())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">"project can not inject"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将路径转化为类名</span></span><br><span class="line">        String className = classPath.substring(<span class="number">0</span>, classPath.length() - <span class="number">6</span>)</span><br><span class="line">                .replace(<span class="string">'/'</span>, <span class="string">'.'</span>)</span><br><span class="line">                .replace(<span class="string">'/'</span>, <span class="string">'.'</span>)</span><br><span class="line">        CtClass c = POOL.getCtClass(className)</span><br><span class="line">        <span class="comment">//类需要解冻后便可以修改,否则无法修改</span></span><br><span class="line">        <span class="keyword">if</span> (c.isFrozen()) &#123;</span><br><span class="line">            c.defrost()</span><br><span class="line">        &#125;</span><br><span class="line">        CtMethod[] methods = c.getDeclaredMethods()</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (CtMethod <span class="string">method :</span> methods) &#123;</span><br><span class="line">            <span class="comment">//排除空方法和 native 方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.isEmpty() || Modifier.isNative(method.getModifiers())) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">            insertTime(project.Trace.logLevel, className.replace(packageName + <span class="string">"."</span>, <span class="string">""</span>), method)</span><br><span class="line">        &#125;</span><br><span class="line">        c.writeFile(path)</span><br><span class="line">        c.detach()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> insertTime(String logLevel, String className, CtMethod method) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            CodeAttribute codeAttribute = method.getMethodInfo().getCodeAttribute()</span><br><span class="line">            LocalVariableAttribute attribute = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag)</span><br><span class="line">            <span class="keyword">int</span> size = method.getParameterTypes().length</span><br><span class="line">            String[] paramTypes = <span class="keyword">new</span> String[size]</span><br><span class="line">            <span class="keyword">if</span> (attribute == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">//获取入参类型</span></span><br><span class="line">                paramTypes[i] = method.getParameterTypes()[i].name</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> stringType = POOL.getCtClass(<span class="string">"java.lang.String"</span>)</span><br><span class="line">            <span class="keyword">def</span> objType = POOL.getCtClass(<span class="string">"java.lang.Object"</span>)</span><br><span class="line">            <span class="comment">//定义局部变量</span></span><br><span class="line">            method.addLocalVariable(<span class="string">"startTime"</span>, CtClass.longType)</span><br><span class="line">            method.addLocalVariable(<span class="string">"endTime"</span>, CtClass.longType)</span><br><span class="line">            <span class="comment">//打印类名</span></span><br><span class="line">            method.addLocalVariable(<span class="string">"className"</span>, stringType)</span><br><span class="line">            <span class="comment">//打印方法名</span></span><br><span class="line">            method.addLocalVariable(<span class="string">"methodName"</span>, stringType)</span><br><span class="line">            <span class="comment">//打印行号</span></span><br><span class="line">            method.addLocalVariable(<span class="string">"lineNumber"</span>, CtClass.intType)</span><br><span class="line">            <span class="comment">//打印返回值</span></span><br><span class="line">            method.addLocalVariable(<span class="string">"returnObj"</span>, objType)</span><br><span class="line"></span><br><span class="line">            StringBuilder startInjectSB = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//*** 省略插入代码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法前插入 Log</span></span><br><span class="line">            method.insertBefore(startInjectSB.toString())</span><br><span class="line"></span><br><span class="line">            StringBuilder endInjectSB = <span class="keyword">new</span> StringBuilder()</span><br><span class="line">            <span class="comment">//*** 省略插入代码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法 return 前插入 Log</span></span><br><span class="line">            method.insertAfter(endInjectSB.toString())</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Javassit 语法相对简单,在看过参考文档和一些简单的资料就可以直接上手.</p>
<h4 id="用法及项目地址"><a href="#用法及项目地址" class="headerlink" title="用法及项目地址"></a>用法及项目地址</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">项目 gradle</span><br><span class="line"><span class="keyword">classpath</span> <span class="string">'cn.libery.analysis:trace:1.0.1'</span> </span><br><span class="line">module gradle</span><br><span class="line">apply plugin: <span class="string">'analysis-trace'</span> </span><br><span class="line">Trace &#123;</span><br><span class="line">        <span class="comment">// 改变配置值后 需要先 clean 项目</span></span><br><span class="line">        <span class="comment">//是否启用插件</span></span><br><span class="line">        enabled <span class="keyword">true</span></span><br><span class="line">        <span class="comment">//包名(非 applicationId)</span></span><br><span class="line">        packageName <span class="string">"cn.libery.analysis.sample"</span></span><br><span class="line">        <span class="comment">//日志等级 和 Logcat 对应</span></span><br><span class="line">        logLevel <span class="string">"i"</span></span><br><span class="line">        <span class="comment">//排除的类,可以是多个</span></span><br><span class="line">        classExcludes = [<span class="string">"cn.libery.analysis.sample.Logger"</span>,</span><br><span class="line">                        <span class="string">"cn.libery.analysis.sample.Logger2"</span>]</span><br><span class="line">        <span class="comment">//排除的包,可以是多个</span></span><br><span class="line">        packageExcludes = [<span class="string">"cn.libery.analysis.sample.test"</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以参考 Github 中 sample 配置<br><a href="https://github.com/Thewhitelight/Analysis">Github</a><br> <a href="https://bintray.com/light/Android/trace/_latestVersion" target="_blank" rel="noopener"> <img src="https://api.bintray.com/packages/light/Android/trace/images/download.svg" alt="Download"> </a></p>
<p><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/ic_analysis_trace.png" alt="效果图"><br>-&gt; 打印入参<br>&lt;- 打印耗时及返回值</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">沪江网校 AspectJ</a><br><a href="https://www.jianshu.com/p/43424242846b" target="_blank" rel="noopener">Javassist 使用指南</a><br><a href="https://www.jianshu.com/p/44d39585fc20" target="_blank" rel="noopener">AspectJ 和 Javassist 对比</a><br><a href="https://www.mekau.com/4880.html" target="_blank" rel="noopener">AspectJ 语法</a><br><a href="https://github.com/JakeWharton/hugo">hugo</a><br><a href="https://stackoverflow.com/questions/44364633/aspectj-doesnt-work-with-kotlin" target="_blank" rel="noopener">AspectJ 适配 Kotlin</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AspectJ</tag>
        <tag>Javassist</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开发小技巧</title>
    <url>/2018/12/07/android-tips/</url>
    <content><![CDATA[<p>开发中的一些小技巧记录</p>
<h2 id="ConstraintLayout-布局文字显示宽度"><a href="#ConstraintLayout-布局文字显示宽度" class="headerlink" title="ConstraintLayout 布局文字显示宽度"></a>ConstraintLayout 布局文字显示宽度</h2><p>当 TextView 左右都有 View 且文字显示不下时需要省略号,如下图所示<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/ic_android_tips_constaint_1.png" alt><br><strong>解决办法:</strong><br>如果<code>layout_width=&quot;match_parent&quot;</code>或者<code>ayout_width=&quot;wrap_content&quot;</code>,则文字显示有问题<br>需要设置为<code>layout_width=&quot;0dp&quot; layout_constraintLeft_toLeftOf 为向左对其 layout_constraintRight_toLeftOf 为向右对其图片</code>,这样就可以正确显示内容了.<br>对于 ConstraintLayout 内所有内容都应该要有相对位置的设置,不然会出现意想不到的问题.<br>示例代码:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/pin_tuan_title"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_marginTop</span>=<span class="string">"@dimen/toolbar_expand_size"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_marginRight</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:ellipsize</span>=<span class="string">"end"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:includeFontPadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:maxLines</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:textColor</span>=<span class="string">"@color/main_black"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:textSize</span>=<span class="string">"16sp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:textStyle</span>=<span class="string">"bold"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">"@id/pin_tuan_more"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">tools:text</span>=<span class="string">"商品商品商品商品商品商品商品商品商品商品商品商品商品商品商品商品商品商品商品商品"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="全面屏适配-BottomSheet"><a href="#全面屏适配-BottomSheet" class="headerlink" title="全面屏适配 BottomSheet"></a>全面屏适配 BottomSheet</h2><p>我们的项目已经适配过全面屏了,适配方式也很简单,在 AndroidManifest 文件中添加<code>&lt;meta-data 
    android:name=&quot;android.max_aspect&quot;
    android:value=&quot;2.1&quot;/&gt;</code>,但是在使用 BottomSheetDialog 时出现了意想不到的结果,如下图所示<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/ic_android_tips_bottomsheet.png" alt>在最屏幕地步出现了布局上移的情况,而移动的距离正好是屏幕圆角的开始地方.<br><strong>解决办法:</strong><br>使用 BottomSheetDialogFragment 可以避免这个问题.</p>
<h2 id="快速添加简单动画"><a href="#快速添加简单动画" class="headerlink" title="快速添加简单动画"></a>快速添加简单动画</h2><p>当我们设置 View 的可见与不可见时感觉太生硬，可以给父布局添加<code>android:animateLayoutChanges=&quot;true&quot;</code>属性,当然这种适用于很简单的动画,这个属性开启了默认的<code>LayoutTransition</code>.它有五种类型对应不同的动作.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开发异常总结</title>
    <url>/2018/12/07/android-exception-summary/</url>
    <content><![CDATA[<p>在开发过程中遇到各种不太常见的问题,在此记录.</p>
<h1 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h1><h2 id="Android-8-1-apk-安装权限问题-android-permission-ACCESS-ALL-DOWNLOADS"><a href="#Android-8-1-apk-安装权限问题-android-permission-ACCESS-ALL-DOWNLOADS" class="headerlink" title="Android 8.1 apk 安装权限问题 android.permission.ACCESS_ALL_DOWNLOADS"></a>Android 8.1 apk 安装权限问题 android.permission.ACCESS_ALL_DOWNLOADS</h2><p>targetVersion 28 应用内更新安装 apk 如果没有添加flag将会引起以下错误,在华为 8.1.0(27) 系统遇到此问题,但是三星 8.0(26) 系统则没有,估计是内部处理逻辑不同吧.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Writing exception to parceljava.lang.SecurityException: Permission Denial: reading com.android.providers.downloads.DownloadProvider uri content://downloads/all_downloads/7 from pid=3633, uid=10037 requires android.permission.ACCESS_ALL_DOWNLOADS, or grantUriPermission()</span><br><span class="line">    at android.content.ContentProvider.enforceReadPermissionInner(ContentProvider.java:631)</span><br><span class="line">    at android.content.ContentProvider$Transport.enforceReadPermission(ContentProvider.java:501)</span><br><span class="line">    at android.content.ContentProvider$Transport.enforceFilePermission(ContentProvider.java:492)</span><br><span class="line">    at android.content.ContentProvider$Transport.openTypedAssetFile(ContentProvider.java:420)</span><br><span class="line">    at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:302)</span><br><span class="line">    at android.os.Binder.execTransact(Binder.java:698)</span><br></pre></td></tr></table></figure></p>
<p>解决办法: 添加<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</code><br>完整安装代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">       intent.setDataAndType(downloadFileUri, <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">       intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">       intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">       mContext.startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="TimeoutException"><a href="#TimeoutException" class="headerlink" title="TimeoutException"></a>TimeoutException</h2><p>在 bugly 中看到个别这种错误<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/exception_timeout.png" alt>但是机型和页面等具体日志都没有,所以只能猜测问题.<br>查看源码,这个错误在这里被抛出来<a href="http://androidxref.com/9.0.0_r3/xref/libcore/libart/src/main/java/java/lang/Daemons.java#396" target="_blank" rel="noopener">finalizerTimedOut()</a>,根据报错和源码查看可以得知是由于 Finalizer 对象创建过多导致这个报错.120s 后抛这个错,搜索了下发现是 oppo 的系统规定的120s,所以估计这个问题在 oppo 手机比较多.<br>解决办法:</p>
<ol>
<li>重写 该对象的 finalize 方法并手动 GC,但是不会可靠,只能尽量减少此类问题</li>
<li>尽可能少的创建该对象</li>
<li>通过反射置空 FinalizerWatchdogDaemon 中的 thread ,这样不会执行此线程,便不会有异常(<a href="https://stackoverflow.com/questions/24021609/how-to-handle-java-util-concurrent-timeoutexception-android-os-binderproxy-fin),这个里有个回答介绍了此做法" target="_blank" rel="noopener">https://stackoverflow.com/questions/24021609/how-to-handle-java-util-concurrent-timeoutexception-android-os-binderproxy-fin),这个里有个回答介绍了此做法</a><br><a href="https://yq.aliyun.com/articles/225755" target="_blank" rel="noopener">再谈Finalizer对象–大型App中内存与性能的隐性杀手</a> 这篇文章对这个问题分析的很透彻,并且天猫对 Finalizer 有自己的监控体系,这个方法真是羡慕.</li>
</ol>
<h2 id="java-lang-IllegalStateException-Only-fullscreen-opaque-activities-can-request-orientation"><a href="#java-lang-IllegalStateException-Only-fullscreen-opaque-activities-can-request-orientation" class="headerlink" title="java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation"></a>java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation</h2><p>在 bugly 发现微信分享 WXEntryActivity 出现了这个 bug,并且都是8.0的设备<br>查看 8.0 源码发现在<a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/39791594560b2326625b663ed6796882900c220f/core/java/android/app/Activity.java#L984">这里</a>抛异常,但是我在 9.0 源码中又找不到这个方法,应该是被去掉了,不太理解这么做的原因是什么.<br>根据<code>ActivityInfo.isTranslucentOrFloating</code>方法得知,凡是在 Activity 的 theme 中设置了 <code>android:windowIsFloating 或 android:windowSwipeToDismiss 或 android:windowIsTranslucent</code>的值为真且指定了屏幕方向,都会抛出这个异常.<br>在 AndroidManifest 中查看发现,原来当时配置 WXEntryActivity 时设置了<code>android:screenOrientation=&quot;portrait&quot;
            android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot;</code><br>由于这个 Activity 不对用户展示只是做了分发功能,所以去除<code>android:screenOrientation=&quot;portrait&quot;</code>即可.<br>这种兼容性适配坑真是太多了,都是泪啊.</p>
<h2 id="自定义相机拍照时出现-RuntimeException-takePicture-failed"><a href="#自定义相机拍照时出现-RuntimeException-takePicture-failed" class="headerlink" title="自定义相机拍照时出现 RuntimeException: takePicture failed"></a>自定义相机拍照时出现 RuntimeException: takePicture failed</h2><p>在线上看到这个 bug 时一头雾水,看源码也看不到一场抛出点,因为直接调用了 native 方法,自己对于 jni 不太了解,只能通过手动测试复现问题了,可是在原来的测试中从来没出现过这样的问题.以为是权限被拒绝导致相机没启动就点击拍照抛出这个错,在各种尝试后还是不能复现.最后在无意中将拍照键快速连击了之后抛出了这个一场,终于知道问题所在了.<br>解决起来很简单,只需要在点击之后将拍照按钮设置为不可用,拍完照的回调里设置为可用就可以了.</p>
<h2 id="RemoteException-Remote-stack-trace-at-com-android-server-am-ActivityManagerService-enforcePermission"><a href="#RemoteException-Remote-stack-trace-at-com-android-server-am-ActivityManagerService-enforcePermission" class="headerlink" title="RemoteException:Remote stack trace: at com.android.server.am.ActivityManagerService.enforcePermission()"></a>RemoteException:Remote stack trace: at com.android.server.am.ActivityManagerService.enforcePermission()</h2><p>测试环境里当 App 在后台时,有时会弹出异常崩溃提示框,然后再 bugly 中发现异常只在 9.0 设备里出现,看了下日志发现是 Leakcanary 库引起的.<br>在 9.0 源码里 AMS 的<code>enforcePermission</code>方法检查了<code>android.permission.FOREGROUND_SERVICE</code>权限,由于 AndroidManifest 文件没有配置这个权限,所以导致异常.在 9.0 里<a href="https://developer.android.com/reference/android/app/Service.html#startForeground(int,%20android.app.Notification" target="_blank" rel="noopener">创建前台服务</a>)都必须申请这个权限.<br>对于应用 targetSdkVersion 的迁移一定要阅读 Android 官方的<a href="https://developer.android.com/about/versions/pie/android-9.0-migration" target="_blank" rel="noopener">迁移提示</a>以免出现重大问题.</p>
<ul>
<li>对于 9.0 多进程使用 WebView 也作出了重大改变,可以参考<a href="https://developer.android.com/about/versions/pie/android-9.0-changes-28#web-data-dirs" target="_blank" rel="noopener">行为变更</a>里的建议修改</li>
</ul>
<h2 id="资源文件统一存放-不能随意申明否则会导致-FileNotFoundException"><a href="#资源文件统一存放-不能随意申明否则会导致-FileNotFoundException" class="headerlink" title="资源文件统一存放,不能随意申明否则会导致 FileNotFoundException"></a>资源文件统一存放,不能随意申明否则会导致 FileNotFoundException</h2><p>项目图片资源文件都在 xhdpi 下,但是由于多模块间引用,有时候不去依赖模块而是直接在自己模块里申明<code>&lt;item name=&quot;test&quot;  type=&quot;drawable&quot;/&gt;</code>一下,在屏幕分辨率高于 xhdpi 的手机上是正常运行,但是在低于这个屏幕分辨率下,就会直接读取了空的申明资源,导致会抛出<code>java.io.FileNotFoundException</code>.</p>
<h1 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h1><h2 id="SSL异常"><a href="#SSL异常" class="headerlink" title="SSL异常"></a>SSL异常</h2><p>电脑开着代理后,AS编译时有新的三方库更新时,会提示SSL错误<br>解决办法:关闭代理,重启AS(必须 command+q 退出AS)</p>
<h2 id="app-transformNativeLibsWithStripDebugSymbolForProduceRelease-not-found-mips64el-linux-android-strip"><a href="#app-transformNativeLibsWithStripDebugSymbolForProduceRelease-not-found-mips64el-linux-android-strip" class="headerlink" title="app:transformNativeLibsWithStripDebugSymbolForProduceRelease, not found mips64el-linux-android-strip"></a>app:transformNativeLibsWithStripDebugSymbolForProduceRelease, not found mips64el-linux-android-strip</h2><p>项目环境 AS 3.2.1, Gradle 3.0.1, NDK 17, 配置 NDK 后出现如下异常<img src="https://def-201655.cos.ap-shanghai.myqcloud.com/ic_android_exception_ndk.png" alt>打开异常里抛出的文件路径发现没有找到这个文件,原因是 17 里删除了这个配置.<br>解决办法:</p>
<ol>
<li>Gradle 版本升级到最新,现在是 3.2.1,但是这样做太麻烦了,如果版本较低要做大量的适配工作.</li>
<li>下载 NDK 16,将 ndk-bundle/ 文件夹下的文件全部替换掉</li>
<li>下载 NDK 16,将 mips64el-linux-android-strip 复制到抛错提示的文件路径里</li>
</ol>
<h2 id="PKIX-path-building-failed"><a href="#PKIX-path-building-failed" class="headerlink" title="PKIX path building failed"></a>PKIX path building failed</h2><p>报错信息 <code>sun.security.validator.ValidatorException: PKIX path building failed:
sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</code><br>解决办法:<br>关闭代理,点击 File-&gt;invalidate Caches/Restart 重启 AS</p>
<p>Error occurred while communicating with CMake server. Check log /Users/libery_tuya/Company/react-native/ReactAndroid/.externalNativeBuild/cmake/debug/armeabi/cmake_server_log.txt for additional information.</p>
<h2 id="打混淆包后-有包名被改为类似a-a-a"><a href="#打混淆包后-有包名被改为类似a-a-a" class="headerlink" title="打混淆包后,有包名被改为类似a.a.a"></a>打混淆包后,有包名被改为类似<code>a.a.a</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        //需要加入 Android默认混淆规则 proguard-android.txt </span><br><span class="line">        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>异常回顾</tag>
        <tag>版本适配</tag>
        <tag>兼容性问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 8.0 自定义通知铃声</title>
    <url>/2018/12/04/notification-8-0-sound/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Android 系统不断的更新, targetVersion 一直定在 25 ,感觉差的有点多,如果还不升级更新,以后再改估计坑会更多,所以在新的迭代里,将 targetVersion 升级到 28 . 果然和预想的一样,有适配的问题出现了.<br>在 8.0 和 8.1 的手机上通知不能播放自定义铃声,5.0.2 的手机又是可以正常播放.自定义播放铃声使用<code>channel.setSound(notificationUri, Notification.AUDIO_ATTRIBUTES_DEFAULT);</code>,然后看到网上说调整<code>channel.setImportance()</code>发现还是无效,但是设置这个值会影响通知的显示和是否震动、显示指示灯、静音等情况.抱着试一试的心态使用 NotificationCompat.Builder 的 setSound() 方法,果然还是不行.<br><a id="more"></a></p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>没折只能硬着头皮看下 api 然后猜猜哪里出问题<img src="https://def-201655.cos.ap-shanghai.myqcloud.com/notification_8.0_setSound.png" alt>看到最后一句话,必须在 createNotificationChannel() 方法之前修改铃声.但是我的代码确实也是这样写的.这里其实对于通知渠道这个概念理解错了.单纯的以为对于不同的铃声只要在同一个渠道里修改铃声就可以了,其实这样的方法是错的.<strong>对于不同的通知类型(铃声不同,指示灯颜色不同、震动模式不同),必须使用不同的渠道(channelId 不同)</strong>,理解了这个就很容易写出真正适配的代码了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.O)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createNotificationChannel</span><span class="params">(String channel_id, Uri voiceUri)</span> </span>&#123;</span><br><span class="line">    NotificationChannel channel = <span class="keyword">new</span> NotificationChannel(channel_id, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line">    channel.setBypassDnd(<span class="keyword">true</span>);<span class="comment">//是否绕过请勿打扰模式</span></span><br><span class="line">    channel.enableLights(<span class="keyword">true</span>);<span class="comment">//闪光灯</span></span><br><span class="line">    channel.setLockscreenVisibility(VISIBILITY_PUBLIC);<span class="comment">//锁屏显示通知</span></span><br><span class="line">    channel.setLightColor(Color.RED);<span class="comment">//闪关灯的灯光颜色</span></span><br><span class="line">    channel.setShowBadge(<span class="keyword">true</span>);<span class="comment">//桌面launcher的消息角标</span></span><br><span class="line">    channel.enableVibration(<span class="keyword">true</span>);<span class="comment">//是否允许震动</span></span><br><span class="line">    channel.setVibrationPattern(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>&#125;);<span class="comment">//设置震动模式</span></span><br><span class="line">    <span class="keyword">if</span> (voiceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当无特殊通知铃声时,使用系统默认</span></span><br><span class="line">        Uri uri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);</span><br><span class="line">        channel.setSound(uri, Notification.AUDIO_ATTRIBUTES_DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        channel.setSound(voiceUri, Notification.AUDIO_ATTRIBUTES_DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    getManager().createNotificationChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> NotificationManager <span class="title">getManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mManager = (NotificationManager) MyApp.getInstance().getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intent       点击通知打开相应 Activity 的 Intent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> title        通知标题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content      通知内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pushId       pushId 不能重复</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> soundCommand 通知铃声类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendNotify</span><span class="params">(Context context, Intent intent, String title, String content, <span class="keyword">int</span> pushId, String soundCommand)</span> </span>&#123;</span><br><span class="line">    NotificationCompat.Builder builder;</span><br><span class="line">    PendingIntent contentIntent = PendingIntent.getActivity(context, pushId, intent,</span><br><span class="line">            PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    Uri uri = notifyVoice(soundCommand);</span><br><span class="line">    <span class="comment">//使用 hashCode 保证不同类型渠道 channelId 不重复</span></span><br><span class="line">    String id = uri == <span class="keyword">null</span> ? String.valueOf(<span class="string">"channelId"</span>.hashCode()) : String.valueOf(uri.hashCode());</span><br><span class="line">    builder = <span class="keyword">new</span> NotificationCompat.Builder(MyApp.getInstance(), id);</span><br><span class="line">    builder.setSmallIcon(R.drawable.ic_notify)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher))</span><br><span class="line">            .setContentTitle(title)</span><br><span class="line">            .setContentText(content)</span><br><span class="line">            .setFullScreenIntent(<span class="keyword">null</span>, <span class="keyword">true</span>)</span><br><span class="line">            .setContentIntent(contentIntent)</span><br><span class="line">            .setPriority(NotificationCompat.PRIORITY_DEFAULT)</span><br><span class="line">            .setTicker(content)</span><br><span class="line">            .setDefaults(DEFAULT_LIGHTS)</span><br><span class="line">            .setVisibility(VISIBILITY_PUBLIC)</span><br><span class="line">            .setDefaults(DEFAULT_VIBRATE)</span><br><span class="line">            .setWhen(System.currentTimeMillis())</span><br><span class="line">            .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">            .setOnlyAlertOnce(<span class="keyword">true</span>)</span><br><span class="line">            .setOngoing(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        createNotificationChannel(id, uri);</span><br><span class="line">    &#125;</span><br><span class="line">    getManager().notify(pushId, builder.build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Uri <span class="title">notifyVoice</span><span class="params">(String soundCommand)</span> </span>&#123;</span><br><span class="line">    Logger.e(soundCommand);</span><br><span class="line">    <span class="keyword">int</span> notifyVoice;</span><br><span class="line">    <span class="keyword">switch</span> (soundCommand) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"N"</span>:</span><br><span class="line">            notifyVoice = R.raw.notify_new_customer;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"O"</span>:</span><br><span class="line">            notifyVoice = R.raw.notify_new_order;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            notifyVoice = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> notifyVoice == <span class="number">0</span> ? <span class="keyword">null</span> : Uri.parse(<span class="string">"android.resource://"</span> + BuildConfig.APPLICATION_ID + <span class="string">"/"</span> + notifyVoice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这是使用不同渠道方式实现了这个需求,如果感觉不想让用户对于这么多渠道做相应的设置(在 8.0 以上,用户可以针对不同的通知渠道设置相应的行为),或者希望每条通知的铃声都可以播放完整,那么可以使用 Ringtone 来播放音频文件,并且可以只设置一个通知渠道.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Uri uri = notifyVoice(soundCommand);</span><br><span class="line">Ringtone ringtone = RingtoneManager.getRingtone(MyApp.getInstance(), uri);</span><br><span class="line"><span class="keyword">if</span> (ringtone != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ringtone.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样就需要通知取消时 stop 正在播放的音频.可以通过<code>builder.setDeleteIntent()</code>配合 BroadcastReceiver 来取消播放.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/48986856/android-notification-setsound-is-not-working" target="_blank" rel="noopener">Android notification setSound is not working</a><br><a href="https://www.jianshu.com/p/4b9fb73762df" target="_blank" rel="noopener">Notification框架简介</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>版本适配</tag>
      </tags>
  </entry>
  <entry>
    <title>仿小米返回交互</title>
    <url>/2018/09/28/android-slideback/</url>
    <content><![CDATA[<p>进入全面屏时代,iPhone 的交互是业界标杆,所以Android阵营都向其靠拢.小米全面屏手势是我挺喜欢的交互.所以模仿下小米的返回操作.其返回逻辑远不如微信返回动画复杂,几乎没有机型适配问题的存在.<br><a id="more"></a><br>动画效果如图<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/7g4t2-ihykn.gif" alt></p>
<p>看到动画效果我们需要达到的效果是在 Activity 的 DecorView 上绘制此 View,所以就像当于我们所有页面的的根布局需要添加此 View,如果每个页面都手动添加,则显得太过麻烦,显然在抽象的 BaseActivity 中 setContentView 方法之后调用<code>activity.getWindow().getDecorView()</code>,然后获取 content 根布局<code>FrameLayout content = viewGroup.findViewById(android.R.id.content); content.addView(slideBackView);</code>将我们带有返回 View 的布局添加到 FameLayout 的顶层,这样就达到的最小化的修改代码实现效果.</p>
<h1 id="对于返回图形的绘制-主要运用了触摸事件、贝塞尔曲线等知识点"><a href="#对于返回图形的绘制-主要运用了触摸事件、贝塞尔曲线等知识点" class="headerlink" title="对于返回图形的绘制,主要运用了触摸事件、贝塞尔曲线等知识点"></a>对于返回图形的绘制,主要运用了触摸事件、贝塞尔曲线等知识点</h1><ul>
<li>触摸事件,在 View 内重写 onTouchEvent 方法,判断左右滑动并且根据滑动距离绘制返回图形宽度</li>
<li>对于返回图形可以余弦公式,也使用贝塞尔曲线画成,但贝塞尔曲线看起来更加顺滑自然,但是 Android 原生最高支持三阶,对于我们所要绘制的图形三阶会不够自然,使用六阶会比较好,但是又不支持,所以只能由三个二阶组合成返回图形<br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/bezier_3.png" alt="三阶贝塞尔曲线"><br><img src="https://def-201655.cos.ap-shanghai.myqcloud.com/bezier_6.png" alt="六阶贝塞尔曲线"></li>
</ul>
<h2 id="View触摸事件"><a href="#View触摸事件" class="headerlink" title="View触摸事件"></a>View触摸事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左边视差阈值,为 View 的 1/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> thresholdLeft;</span><br><span class="line"><span class="comment">//右边边视差阈值,为 View 的 2/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> thresholdRight;</span><br><span class="line"><span class="comment">//返回图形的最大宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> backMaxWidth;</span><br><span class="line"><span class="comment">//绘制返回图形的最小边距</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> backEdgeWidth;</span><br><span class="line"><span class="comment">//视差的变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> bufferX;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前动作下 View 的X坐标点,不能用 getRawX,否则获取的是屏幕上的坐标</span></span><br><span class="line">        <span class="keyword">float</span> currentX = ev.getX();</span><br><span class="line">        currentY = ev.getY();</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">//按下时 View 的X坐标点</span></span><br><span class="line">                downX = ev.getX();</span><br><span class="line">                forwardX = downX;</span><br><span class="line">                <span class="keyword">if</span> (downX &lt;= backEdgeWidth) &#123;</span><br><span class="line">                <span class="comment">//当按下的X坐标&lt;最小触发边距时,认为有效触发绘制逻辑并绘制左边返回图形</span></span><br><span class="line">                    isEdge = <span class="keyword">true</span>;</span><br><span class="line">                    left = <span class="keyword">true</span>;</span><br><span class="line">                    right = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downX &gt;= getWidth() - backEdgeWidth) &#123;</span><br><span class="line">                <span class="comment">//当按下的X坐标&gt;(View 宽度-最小触发边距)时,认为有效触发绘制逻辑并绘制右边返回图形</span></span><br><span class="line">                    isEdge = <span class="keyword">true</span>;</span><br><span class="line">                    right = <span class="keyword">true</span>;</span><br><span class="line">                    left = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">//当前滑动到的点与按下时的点X坐标的距离</span></span><br><span class="line">                deltaX = currentX - downX;</span><br><span class="line">                <span class="comment">//滑动距离 判断连续滑动时的方向</span></span><br><span class="line">                <span class="keyword">float</span> diff = forwardX - currentX;</span><br><span class="line">                <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//向左滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (currentX &lt; thresholdLeft &amp;&amp; left) &#123;</span><br><span class="line">                        <span class="comment">//当绘制左边图形、向左滑动时、当前小于屏幕1/3处时,绘制时差效果</span></span><br><span class="line">                        deltaX = backMaxWidth;</span><br><span class="line">                        deltaX -= (thresholdLeft - currentX) / <span class="number">2</span>;</span><br><span class="line">                        bufferX = deltaX;</span><br><span class="line">                        <span class="keyword">if</span> (deltaX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            deltaX = <span class="number">0</span>;</span><br><span class="line">                            bufferX = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((currentX &gt; thresholdRight) &amp;&amp; right) &#123;</span><br><span class="line">                        <span class="comment">//当绘制右边图形、向左滑动时、当前大于屏幕2/3处时,绘制时差效果</span></span><br><span class="line">                         bufferX -= diff;</span><br><span class="line">                         deltaX = bufferX;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//向右滑动</span></span><br><span class="line">                    <span class="keyword">if</span> ((currentX &lt; thresholdLeft) &amp;&amp; left) &#123;</span><br><span class="line">                        <span class="comment">//当绘制左边图形、向右滑动时、当前小于屏幕1/3处时,绘制时差效果</span></span><br><span class="line">                        bufferX += Math.abs(diff);</span><br><span class="line">                        deltaX = bufferX;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentX &gt; thresholdRight &amp;&amp; right) &#123;</span><br><span class="line">                         <span class="comment">//当绘制右边边图形、向右滑动时、当前大于屏幕2/3处时,绘制时差效果</span></span><br><span class="line">                        deltaX = -backMaxWidth;</span><br><span class="line">                        deltaX += (currentX - thresholdRight) / <span class="number">2</span>;</span><br><span class="line">                        bufferX = deltaX;</span><br><span class="line">                        <span class="keyword">if</span> (deltaX &lt; -backMaxWidth) &#123;</span><br><span class="line">                            deltaX = -backMaxWidth;</span><br><span class="line">                            bufferX = -backMaxWidth;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录当前滑动的X坐标,与下次滑动点做比较</span></span><br><span class="line">                forwardX = currentX;</span><br><span class="line">                <span class="keyword">if</span> (isEdge) &#123;</span><br><span class="line">                    invalidate();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">if</span> (isEdge) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (deltaX &gt;= backMaxWidth &amp;&amp; left) &#123;</span><br><span class="line">                        <span class="comment">//当绘图形宽度为最大时并抬起,表示返回</span></span><br><span class="line">                        back();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(deltaX) &gt;= backMaxWidth &amp;&amp; right) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!isOnlyLeftBack) &#123;</span><br><span class="line">                            <span class="comment">//如果绘制右边时,出发返回逻辑</span></span><br><span class="line">                            back();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    deltaX = <span class="number">0</span>;</span><br><span class="line">                    invalidate();</span><br><span class="line">                &#125;</span><br><span class="line">                left = <span class="keyword">false</span>;</span><br><span class="line">                right = <span class="keyword">false</span>;</span><br><span class="line">                isEdge = <span class="keyword">false</span>;</span><br><span class="line">                bufferX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isEdge;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码,分析了手势与绘制图形的关系,具体逻辑可以根据效果分析,视差部分的效果可以根据自身进行调整.</p>
<h2 id="贝塞尔曲线绘制"><a href="#贝塞尔曲线绘制" class="headerlink" title="贝塞尔曲线绘制"></a>贝塞尔曲线绘制</h2><p>使用贝塞尔曲线绘制返回图形和里面的返回图标.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//返回图形画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint backPaint;</span><br><span class="line">    <span class="comment">//返回图标画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint arrowPaint;</span><br><span class="line">    <span class="comment">//返回图形路径</span></span><br><span class="line">    <span class="keyword">private</span> Path backPath;</span><br><span class="line">    <span class="comment">//返回图标路径</span></span><br><span class="line">    <span class="keyword">private</span> Path arrowPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        backPath = <span class="keyword">new</span> Path();</span><br><span class="line">        arrowPath = <span class="keyword">new</span> Path();</span><br><span class="line"></span><br><span class="line">        backPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        backPaint.setColor(<span class="number">0xAA000000</span>);</span><br><span class="line">        backPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line"></span><br><span class="line">        arrowPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        arrowPaint.setColor(Color.WHITE);</span><br><span class="line">        arrowPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        arrowPaint.setStrokeWidth(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//当deltaX超过最大距离时,设置为最大距离</span></span><br><span class="line">        <span class="keyword">if</span> (deltaX &gt; backMaxWidth &amp;&amp; left) &#123;</span><br><span class="line">            deltaX = backMaxWidth;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &lt; -backMaxWidth &amp;&amp; right) &#123;</span><br><span class="line">            deltaX = -backMaxWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化绘制坐标点Y</span></span><br><span class="line">        <span class="keyword">float</span> deltaY = currentY - backViewHeight / <span class="number">2</span>;</span><br><span class="line">        backPath.reset();</span><br><span class="line">        arrowPath.reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deltaX &gt; <span class="number">0</span> &amp;&amp; left) &#123;</span><br><span class="line">            backPath.moveTo(<span class="number">0</span>, deltaY);</span><br><span class="line">            backPath.quadTo(<span class="number">0</span>, backViewHeight / <span class="number">4</span> + deltaY, deltaX / <span class="number">3</span>, backViewHeight * <span class="number">3</span> / <span class="number">8</span> + deltaY);</span><br><span class="line">            backPath.quadTo(deltaX * <span class="number">5</span> / <span class="number">8</span>, backViewHeight / <span class="number">2</span> + deltaY, deltaX / <span class="number">3</span>, backViewHeight * <span class="number">5</span> / <span class="number">8</span> + deltaY);</span><br><span class="line">            backPath.quadTo(<span class="number">0</span>, backViewHeight * <span class="number">6</span> / <span class="number">8</span> + deltaY, <span class="number">0</span>, backViewHeight + deltaY);</span><br><span class="line">            canvas.drawPath(backPath, backPaint);</span><br><span class="line"></span><br><span class="line">            arrowPath.moveTo(deltaX / <span class="number">6</span> + (<span class="number">15</span> * (deltaX / (width / <span class="number">6</span>))), backViewHeight * <span class="number">15</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">            arrowPath.lineTo(deltaX / <span class="number">6</span>, backViewHeight * <span class="number">16.1f</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">            arrowPath.moveTo(deltaX / <span class="number">6</span>, backViewHeight * <span class="number">15.9f</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">            arrowPath.lineTo(deltaX / <span class="number">6</span> + (<span class="number">15</span> * (deltaX / (width / <span class="number">6</span>))), backViewHeight * <span class="number">17</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">            canvas.drawPath(arrowPath, arrowPaint);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaX &lt; <span class="number">0</span> &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOnlyLeftBack) &#123;</span><br><span class="line">                deltaX = Math.abs(deltaX);</span><br><span class="line">                backPath.moveTo(width, deltaY);</span><br><span class="line">                backPath.quadTo(width, backViewHeight / <span class="number">4</span> + deltaY, width - deltaX / <span class="number">3</span>, backViewHeight * <span class="number">3</span> / <span class="number">8</span> + deltaY);</span><br><span class="line">                backPath.quadTo(width - deltaX * <span class="number">5</span> / <span class="number">8</span>, backViewHeight / <span class="number">2</span> + deltaY, width - deltaX / <span class="number">3</span>, backViewHeight * <span class="number">5</span> / <span class="number">8</span> + deltaY);</span><br><span class="line">                backPath.quadTo(width, backViewHeight * <span class="number">6</span> / <span class="number">8</span> + deltaY, width, backViewHeight + deltaY);</span><br><span class="line">                canvas.drawPath(backPath, backPaint);</span><br><span class="line"></span><br><span class="line">                arrowPath.moveTo(width - deltaX / <span class="number">6</span> - (<span class="number">15</span> * (deltaX / (width / <span class="number">6</span>))), backViewHeight * <span class="number">15</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">                arrowPath.lineTo(width - deltaX / <span class="number">6</span>, backViewHeight * <span class="number">16.1f</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">                arrowPath.moveTo(width - deltaX / <span class="number">6</span>, backViewHeight * <span class="number">15.9f</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">                arrowPath.lineTo(width - deltaX / <span class="number">6</span> - (<span class="number">15</span> * (deltaX / (width / <span class="number">6</span>))), backViewHeight * <span class="number">17</span> / <span class="number">32</span> + deltaY);</span><br><span class="line">                canvas.drawPath(arrowPath, arrowPaint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setAlpha(deltaX / backMaxWidth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>返回图形及返回坐标的形状都可以通过这是不同的结束点和控制点去调节,形成自己想要的效果,不过最好先通过绘图软件,分析好想要的图形及其绘制比例.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SlideBack用法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setContent(layoutResID) 替换为</span></span><br><span class="line">SlideBack.Builder().init(layoutResID).build(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用自定义 View 可以作出各种设计师想实现的动画效果,一般使用 onTouchEvent、onMeasure、onLayout、onDraw 等方法,根据实际情况重写这些方法即可实现.通过实现这个效果可以更好的理解 Android 中各种设计,提升自己开发水平.</p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/Thewhitelight/Tinder">GitHub项目地址</a> 里面有一些 library 集合<br><code>cn.libery:slideback:latest</code><br><a href="https://bintray.com/light/Avatar/SlideBack/_latestVersion" target="_blank" rel="noopener"> <img src="https://api.bintray.com/packages/light/Avatar/SlideBack/images/download.svg" alt="Maven"> </a> </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 内存优化实践(下)</title>
    <url>/2018/09/13/android-memory-optimization-3/</url>
    <content><![CDATA[<h1 id="Web-独立进程"><a href="#Web-独立进程" class="headerlink" title="Web 独立进程"></a>Web 独立进程</h1><p>一般应用中会大量使用网页,我们项目由于有家装 VR 页面,如果都放在主进程则会造成大量的内存占用,因此将 WebView 拆分为独立进程运行,从而减轻主进程内存压力很有必要,当内存紧张时,系统则会自动杀死 web 进程.拆分为多进程后,主要问题在于进程间通讯与主进程保活.</p>
<h2 id="拆分-Web-进程"><a href="#拆分-Web-进程" class="headerlink" title="拆分 Web 进程"></a>拆分 Web 进程</h2><p>独立进程分为两种模式,<strong>私有独立进程</strong> 和 <strong>全局独立进程</strong> 两种模式,开始方式也很简单.<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 私有独立进程:与主进程同ShareUID,共享data目录、组件信息、共享内存数据  --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".WebActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">":web"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全局独立进程:与主进程不同ShareUID --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".WebActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:process</span>=<span class="string">".web"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>本项目使用的是第一种方法,因为只与本应用通信,所以不需要为全局独立进程.<br><a id="more"></a></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间的通信方式:</p>
<ol>
<li>Bundle</li>
<li>文件共享</li>
<li>AIDL</li>
<li>Messager</li>
<li>ContentProvider</li>
<li>Socket</li>
</ol>
<p>当打开网页时,发送请求应该带用户信息,原来的信息存储方式是SharePreference,但是这种方式对于多进程调用时,容易出现不稳定的情况,并且它的多进程调用方式已经被标记为废弃,所以为了保证稳定性,使用ContentProvider将其封装,供不同的进程调用.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 web 进程里只是获取用户信息,当web里返回要登录信息时,跳转至主进程里的登录页面,所以只实现了 query 方法,更新 SharePreference 依旧使用了单进程读写模式.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String sAuthoriry = BuildConfig.APPLICATION_ID + <span class="string">".UserProvider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个 name 获取的就是 xml 的文件名,默认取 uri 的 path 字段的第一个</span></span><br><span class="line">        <span class="keyword">if</span> (!sAuthoriry.equals(uri.getAuthority())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        <span class="keyword">if</span> (getContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bundle.putString(<span class="string">"user"</span>, SharedPreferUtil.get(getContext(), Constants.EXTRA_USER_CACHE, <span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BundleCursor(bundle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleCursor</span> <span class="keyword">extends</span> <span class="title">MatrixCursor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Bundle mBundle;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BundleCursor</span><span class="params">(Bundle extras)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="keyword">new</span> String[]&#123;&#125;, <span class="number">0</span>);</span><br><span class="line">            mBundle = extras;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bundle <span class="title">getExtras</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBundle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bundle <span class="title">respond</span><span class="params">(Bundle extras)</span> </span>&#123;</span><br><span class="line">            mBundle = extras;</span><br><span class="line">            <span class="keyword">return</span> mBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(@NonNull Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"No external call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"No external call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"No external call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"No external call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AndroidManifest.xml 配置<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 由于只与本应用通信所以就没有配置权限 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".provider.UserProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.UserProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就配置好了多进程读取 SharePreference 的 ContentProvider,凡是读取用户信息的地方都需替换为如下方式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String authority = <span class="string">"content://"</span> + BuildConfig.APPLICATION_ID + <span class="string">".UserProvider"</span>;</span><br><span class="line">    Uri uri = Uri.parse(authority);</span><br><span class="line">    <span class="comment">//由于多进程模式,所以 Application 会多次初始化,MyApplication.getInstance() 的初始化不能写在某个进程里,如果这样则其他进程获取不到实例,导致这里会出现NPE</span></span><br><span class="line">    Cursor cursor = MyApplication.getInstance().getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Bundle args = cursor.getExtras();</span><br><span class="line">        cursor.close();</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> User.stringToUser(args.getString(<span class="string">"user"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上配置,就可以在不同进程里获取User对象.<br>我们业务中有个逻辑是分享网页,当用户点击网页分享按钮,调起分享页面,然后分享至微信,分享成功返回后调用 js,所以需要在微信回调中通知网页,使用BroadcastReceiver通知网页执行 js 脚本.</p>
<h2 id="多进程注意事项"><a href="#多进程注意事项" class="headerlink" title="多进程注意事项"></a>多进程注意事项</h2><ol>
<li>静态成员和单例模式会失效</li>
<li>线程同步机制失效</li>
<li>SharePreference 稳定性不能保证,使用 ContentProvider 封装,对外提供数据服务</li>
<li>Application 会多次创建,需要注意多进程间使用的对象是否初始化<br>在 web 进程中调用主进程功能都需要注意 Context 和数据的读取,否则会出现空指针的问题.<h1 id="主进程保活"><a href="#主进程保活" class="headerlink" title="主进程保活"></a>主进程保活</h1>在完成进程拆分后测试中发现,当主进程占用一百多 MB 时红米 Note3 机器打开网页进程,再消耗一百多 MB时,系统会自动杀死主进程,导致返回到主进程会再次加载,为了避免这种问题发生,只能在网页进程启动后,将主进程置为前台进程.<br>进程保活话题如果要展开谈,可以写好多东西,这里只介绍我们应用的方法.逻辑很简单就是在主进程中启动一个前台 Service,然后再启动一个相同 ID 的 Service,最后停止一个 Service,这样通知栏里便不会出现通知,而应用在前台 oom_adj 值较高,进程不会被杀死.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepLiveService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTIFICATION_ID = <span class="number">0x11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeepLiveService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</span><br><span class="line">            <span class="comment">//API 18 以下，直接发送 Notification 并将其置为前台</span></span><br><span class="line">            startForeground(NOTIFICATION_ID, <span class="keyword">new</span> Notification());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//API 18 以上，发送 Notification 并将其置为前台后，启动 InnerService</span></span><br><span class="line">            Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>);</span><br><span class="line">            builder.setSmallIcon(R.drawable.push);</span><br><span class="line">            startForeground(NOTIFICATION_ID, builder.build());</span><br><span class="line">            ContextCompat.startForegroundService(getApplicationContext(), <span class="keyword">new</span> Intent(<span class="keyword">this</span>, InnerService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate();</span><br><span class="line">            <span class="comment">//发送与 KeepLiveService 中I D 相同的 Notification，然后取消自己的前台显示</span></span><br><span class="line">            Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>);</span><br><span class="line">            builder.setSmallIcon(R.drawable.push);</span><br><span class="line">            startForeground(NOTIFICATION_ID, builder.build());</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当然 Service 也必须在 AndroidManifest 中注册.</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>compleVerison 27 targetVersion 26 如果再为更高的版本则通知拦会显示出应用正在后台运行,给用户造成不好的体验</li>
<li>为了在用户体验和内存消耗间平衡,在 Application 的 onTrimMemory中,当 level 值大于等于 TRIM_MEMORY_MODERATE 且 Web 进程在后台后,主动杀死 web 进程.</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 内存优化实践(中)</title>
    <url>/2018/09/10/android-memory-optimization-2/</url>
    <content><![CDATA[<p>上一篇从图片加载和布局方面分析怎样优化内存,这样可以解决大部分的 OOM 问题了,但是为了尽可能小的占用内存,我们还需要从其他方面入手,不光是从编程角度,还需要在业务方面配合.</p>
<h1 id="ViewPager-页面使用懒加载"><a href="#ViewPager-页面使用懒加载" class="headerlink" title="ViewPager 页面使用懒加载"></a>ViewPager 页面使用懒加载</h1><p>在首页、搜索等页面中需要使用 ViewPager 承载不同 Fragment,并且有的需要 ViewPager 嵌套 ViewPager,如果进入 Activity 就加载 Fragment 会消耗大量资源,如网络请求、内存、布局绘制耗时耗内存,对用户而言需要等待造成不好的体验.所以需要使用懒加载方式以减少网络请求、布局绘制等不必要的消耗.<br>懒加载的思路就是首次Fragment加载进Activity不可见的时候不初始化布局和请求网络,让Fragment切换为可见时,再加载布局、请求网络,这样就避免首次打开Activity卡顿和消耗不必要内存.在 Fragment 重写<code>setUserVisibleHint(boolean isVisibleToUser)</code>方法便可以获取到,Fragment 是否用户可见.<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFrgment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志位，标志已经初始化完成，因为setUserVisibleHint是在onCreateView之前调用的，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPrepared;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志当前页面是否可见</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isVisible;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不需要懒加载，需要在onAttach时设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNotLazyLoad;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasNotLazyLoad</span><span class="params">(<span class="keyword">boolean</span> hasNotLazyLoad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasNotLazyLoad = hasNotLazyLoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        isPrepared = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(getContentView(), container, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(@NonNull View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        initView(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (hasNotLazyLoad) &#123;</span><br><span class="line">            initData();</span><br><span class="line">            loadData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        isVisible = getUserVisibleHint();</span><br><span class="line">        <span class="keyword">if</span> (isVisible) &#123;</span><br><span class="line">            onVisible();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onInvisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInvisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisible &amp;&amp; isPrepared &amp;&amp; !hasNotLazyLoad) &#123;</span><br><span class="line">            isPrepared = <span class="keyword">false</span>;</span><br><span class="line">            initData();</span><br><span class="line">            loadData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Fragment布局</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布局Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getContentView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化View</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view ContentView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(View view)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化View属性、加载基本数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载网络或者数据库数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样当继承 LazyFragment 后,只需实现四个抽象方法后,就可以完成懒加载.这样的方式也有助于减少网络并发导致 Token 失效的问题.当 ViewPager 中 Fragment 个数过多时,对内存也会造成很大压力,所以需要用<code>setOffscreenPageLimit</code>给 ViewPager 设置一个合适的 limit 值,当 ViewPager 加载 Fragment 超过这个值时,会回收栈底的 Fragment 缓解内存压力.</p>
<h1 id="页面递归调用限制"><a href="#页面递归调用限制" class="headerlink" title="页面递归调用限制"></a>页面递归调用限制</h1><p>当进入商品详情页后又可以进入店铺详情页,店铺详情页就可以进入商品详情页,这样的递归调用,理论情况一定会出现 OOM,就算不出现 OOM 也会让内存压力过大,有可能使应用卡顿.所以需要设置一个阈值,当页面递归调用超过这个阈值后,杀死这个阈值前所以的商品详情页.当然也可以有更复杂的规则,目前我们业务规则这样指定,但是总体思路不变.<br>在 API 14以后,Application 中提供了一个应用生命周期回调的注册方法，用来对应用的生命周期进行集中管理.这样可以免去手动维护 Activity 栈.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 Application 的 onCreate 调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerMainProcessActivityLife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录商品详情页,Activity 也是堆栈结构,所以采用此数据结构</span></span><br><span class="line">    <span class="keyword">final</span> Stack&lt;Activity&gt; activities = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//商品详情页最多加载个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxGoodDetailActivityNum = <span class="number">3</span>;</span><br><span class="line">    registerActivityLifecycleCallbacks(<span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> GoodsDetailActivity) &#123;</span><br><span class="line">                <span class="keyword">if</span> (activities.size() &gt;= maxGoodDetailActivityNum) &#123;</span><br><span class="line">                    activities.peek().finish(); <span class="comment">//移除栈底的详情页</span></span><br><span class="line">                &#125;</span><br><span class="line">                activities.add(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            activities.remove(activity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="复杂长页面使用-vlayout"><a href="#复杂长页面使用-vlayout" class="headerlink" title="复杂长页面使用 vlayout"></a>复杂长页面使用 vlayout</h1><p>对于电商首页而言,页面承载内容需要十分丰富,并且数量也很多,如果使用 ScrollView 根本无法满足,如果使用 RecyclerView 需要编写大量的布局,对数据结构要求很高.十分感谢阿里在的开源项目<a href="https://github.com/alibaba/vlayout">vlayout</a>,简直是编写复杂页面之光.我们目前应用于首页、商品详情页、店铺详情页等结构样式较多,且内容较多的页面.vlayout 支持固定布局、浮动布局、浮动布局、瀑布流布局等复杂布局.<code>vlayout 是一个针对 RecyclerView 的 LayoutManager 扩展, 主要提供一整套布局方案和布局间的组件复用的问题。通过定制化的LayoutManager，接管整个RecyclerView的布局逻辑；LayoutManager管理了一系列LayoutHelper，LayoutHelper负责具体布局逻辑实现的地方；每一个LayoutHelper负责页面某一个范围内的组件布局；不同的LayoutHelper可以做不同的布局逻辑，因此可以在一个RecyclerView页面里提供异构的布局结构，这就能比系统自带的LinearLayoutManager、GridLayoutManager等提供更加丰富的能力。同时支持扩展LayoutHelper来提供更多的布局能力.</code></p>
<h1 id="onDestroy-置空全局变量"><a href="#onDestroy-置空全局变量" class="headerlink" title="onDestroy 置空全局变量"></a>onDestroy 置空全局变量</h1><p>正常情况下,Activity finish 后系统会销毁 Activity 的实例,当该 Actiivty 对象引用没有指向原先分配给该Activity对象的内存时，该内存便成为垃圾.JVM的一个系统级线程会自动释放该内存块.但是这个有可能不及时,我们手动置空后会更加积极的回收内存.<br>原来并没有在意这个操作会带来多大变化,但是在优化过程发现还挺有效.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 内存优化实践(上)</title>
    <url>/2018/09/03/android-memory-optimization/</url>
    <content><![CDATA[<p>一直在写代码,感觉总结反思比较少,自己的表达能力很欠缺,所以想把自己的一些经验记录下来,顺便理清思路.<br>公司项目经历了一两年多的迭代,业务越来越复杂,由于是电商项目,有大量的图片需要加载,页面布局多样化,对 WebView 使用也很多,所以在内存方面开始出现较大的压力.在历经几个迭代处理相关问题后,现在首页 Tab 全部加载后内存比优化前内存使用减少40%,当打开十多个页面后,内存减少有30%以上,从 bugly 的日志来看已经没有 OOM 相关日志了,改进效果还是比较明显.<br><a id="more"></a></p>
<h1 id="针对应用进行分析-优化前主要存在下面几个问题"><a href="#针对应用进行分析-优化前主要存在下面几个问题" class="headerlink" title="针对应用进行分析,优化前主要存在下面几个问题:"></a>针对应用进行分析,优化前主要存在下面几个问题:</h1><ol>
<li>图片问题<ol>
<li>图片内存回收不及时</li>
<li>只有单份本地图片,但放置在 xhdpi 中,当高分辨率手机加载时,会占用较大内存</li>
</ol>
</li>
<li>布局优化<ol>
<li>自定义 View 时,在 xml 根布局使用 LinearLayout 之类,并且在代码里又继承相应的 ViewGroup,造成重复嵌套</li>
<li>在复杂布局中嵌套过的多,RelativeLayout 使用也较多,影响布局测量绘制性能</li>
<li>页面中未经常使用的 View 使用 Gone 隐藏,而未使用 ViewStub,影响绘制性能</li>
</ol>
</li>
<li>某些 ViewPager 页面为使用懒加载</li>
<li>某些页面可以递归调用,而未做任何限制,存在 OOM 风险</li>
<li>复杂长页面使用 ScrollView,造成单页面内存消耗过大</li>
<li>onDestroy 中为将全局变量置空,导致内存回收缓慢</li>
<li>WebView<ol>
<li>非 Web 页面嵌套 WebView,没做好内存释放处理,造成内存占用不能释放</li>
<li>Web未使用独立进程,而 WebView 中 VR 展示,内存消耗严重</li>
</ol>
</li>
</ol>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>有的问题是编码习惯问题,平时没有养成良好的习惯,导致代码维护越来越难做,补丁越打越多,对性能开始产生了影响.<br>有的问题是思考太少,着急写代码而没有考虑好应用场景,对后来的扩展和性能产生了影响.<br>有的则是自己水平不够,没有好好学习,意识不到存在问题.</p>
<p>现在又让我想起了代码整洁之道里的那句话.<div class="note danger">
            <p>让营地比你来时更干净 </p>
          </div>以后在写代码时一定要默念,时刻警惕让其成为一种习惯,这样自己所犯的错误也就少一点.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="图片内存及时释放"><a href="#图片内存及时释放" class="headerlink" title="图片内存及时释放"></a>图片内存及时释放</h2><p>项目目前使用的是图片框架是 Glide3.7.0 版本,由于其他 library 也在依赖这个版本,所以目前还没有迁移到最新版本,打算抽空更新下,毕竟图片加载框架对于加载大量图片的应用还是很重要的,直接关乎体验和性能.Fresco 本身对于图片的请求、内存的优化和各种图形变换,有很好的支持和体验,但是由于其必须指定宽度或者高度,对于目前项目的迁移存在较大的障碍,目前不予考虑.</p>
<p>在整合进项目中,我们使用自定义 ImageView,将 Glide 各种默认策略封装在 View 内,对外直提供默认的方法就可以使用,消除有多余配置,对于特殊的需求提供统一方法,进行自定义配置.简化调用逻辑.</p>
<p>当在页面内滑动时,页面滑出屏幕,这时候 View 已经看不到,但是内存依旧在占用,而没有及时释放,而这样的的情况在打开页面较少时看起来无所谓,但是一旦 Activity 栈中有大量历史 Activity 而未销毁,就会给内存带来很大压力,<strong>雪崩时,没有一片雪花是无辜的</strong>.所以要防范这种情况的发生.如果首页就加载了大量的图片,占用过多内存,那么对于整个程序可使用的内存就会减少很多,用户随便进入多级页面,内存就快预警.</p>
<p>经过上面的分析,及时释放图片占用的最好的时机就是 View 滑出时回收,显示出来时再加载.于是<code>onAttachedToWindow</code>和<code>onDetachedFromWindow</code>这两个 View 生命周期里的方法就起作用了.Activity 中的 onAttachedToWindow调用是在 onResume 之后调用,而 onDetachedFromWindow 调用是在 onDestroy 之后,所以当 Activity 增加时,历史 Activity 屏幕中的图片内存释放不掉,也是一个隐患点,但是配合业务逻辑不会出现特别多的 Activity 叠加的情况,还是可以接受,如果有必要这个点可以以后优化.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartImageView</span> <span class="keyword">extends</span> <span class="title">AppCompatImageView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ··· 省略其他变量</span><br><span class="line">    <span class="keyword">private</span> String mUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">        onAttach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">        onDetach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当Viwe可见时,将图片重新加载</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setImageUrl(mUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将图片不可见时,及时清除View的图片</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDetach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setImageDrawable(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是示例方法,所以很简单的描述清楚原理,对于服务器返回图片的尺寸后,根据View真是大小,计算缩放比例,使用override去加载在屏幕实际尺寸,减少不必要的内存消耗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        DrawableRequestBuilder&lt;String&gt; builder = Glide.with(getContext().getApplicationContext())</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .dontAnimate()<span class="comment">//有的机型出现图片后出现偏移,故去掉加载动画,便恢复正常</span></span><br><span class="line">                    .fitCenter();</span><br><span class="line">            <span class="comment">//不能使用builder.into(this) 以为Context使用ApplicationContext,所以有可能此时view销毁,而图片加载成功后,导致内存泄漏</span></span><br><span class="line">            builder.into(<span class="keyword">new</span> SimpleTarget&lt;GlideDrawable&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(GlideDrawable resource, GlideAnimation&lt;? <span class="keyword">super</span> GlideDrawable&gt; glideAnimation)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; getContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setImageDrawable(resource);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以保证图片在滑出屏幕后内存得到及时的回收,而不用等到界面销毁后才能回收图片内存.最大限度的降低图片对于内存的压力.<br>对于 Android 8.0 以上图片不再使用堆存放,而是分配在 Native 中,并且 <strong>不需要用户手动回收、不受应用内存分配限制</strong>,对于多应用来说真是莫大的好消息,虽然不受最大堆限制,但是当 Native 内存过大也会造成系统层面的 OOM,而且应用本身不会捕获此异常. 在 Android 2.3 以下图片内存分配也是这样的逻辑,由于不能回收不及时所以废弃不使用,但是在 Android 8.0 加入一种自动回收 Native 內存的 NativeAllocationRegistry机制,对开发者而言是透明的.不用手动回收所分配的内存.</p>
<h2 id="本地图片处理"><a href="#本地图片处理" class="headerlink" title="本地图片处理"></a>本地图片处理</h2><ul>
<li>对于本地资源图片需要尽量压缩,设计师给过来就直接放进项目了,再次检查时发现有的图片较大,当载入时会占用更多内存.</li>
<li>对于图片格式可以转换 webp,这种编码格式在大小和质量有很好的平衡,在 Android4.2 版本以上解决了有关bug,可以放心使用,当然可以使用第三方支持到 Android4.1 版本.</li>
<li>对于尺寸较大的图片可以放入 xxhdpi,如果将高分辨率图片放入低密度目录，将会造成低端机占用较大内存可能造成 OOM.<h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2></li>
<li>开发中经常有多个 View 组合,简化 Activity 中代码的逻辑,可以在多个页面复用,比如有时会继承 LinearLayout 然后在构造方法里用 LayouInfflate r将 xml 布局代码加载进来,这个方式看似没有毛病,原来也经常这么写,但是在使用 Layout Inspector 分析布局时发现造成了不必要的嵌套,所以需要改变方式.<ul>
<li>继承各种 Layout 后直接new出所需要的 widget,但是这样不利于直观的分析布局,并且存在大量的 java 代码,很费力.</li>
<li>继承各种 Layout 后并且使用 LayoutInflater 加载 xml 布局,但是 xml 布局里使用 merge,这样就可以减少一层布局嵌套.<br>相比较而言第二种方式更方便、更直观和符合习惯,我们也采用第二种方式.<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:parentTag</span>=<span class="string">"android.widget.FrameLayout"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>使用 parentTag 指定当前布局的是哪种类型.这样做可以实时预览效果,但是根布局的属性都要在 java 代码指定.</p>
<ul>
<li>Google 在 2016 I/O 大会上推出 ConstrainLayout 布局.解决了复杂布局使用各种 Layouts 互相嵌套的问题,可以让布局更加扁平化,对于现在开发使用 LinearLayout, FrameLayout 和 ConstrainLayout 完全足以.具体的用法可以参考<a href="https://developer.android.com/training/constraint-layout/" target="_blank" rel="noopener">ConstrainLayout Guide</a>.</li>
<li><p>打开一个新Activity并且请求网络时,就会出现四种状态:加载中、显示内容、显示错误、显示空页面,对于不经常显示的错误和空页面我们在 Activity 根布局中却一直解析,只是调用 setVisible(GONE),消耗了不必要的性能和内存.因此使用 ViewStub 可以很好的解决这个问题,这个 ViewStub 相当于懒加载,只有记载它时才会初始化,否则不会解析. ViewStub 不能应用 merge 标签.这个特性很适合在首页弹出促销的 WebView,平时不需要加载节省内存.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ViewStub) findViewById(R.id.my_layout)).setVisibility(View.VISIBLE);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">View importPanel = ((ViewStub) findViewById(R.id.my_layout)).inflate();</span><br></pre></td></tr></table></figure>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  android:layout 指定所要加载的布局--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/stub_home_web"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">"@layout/layout_web"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler"></a>Android Profiler</h1><p>内存优化是个任重道远的的过程,需要不断的验证观察,Android Studio 提供了强大的性能分析工具,在 Android Profiler 里可以很方便的观察和分析 CPU、内存和网络的状态.<a href="https://developer.android.google.cn/studio/profile/memory-profiler" target="_blank" rel="noopener">Android Profiler 使用参考</a>里面具体用法,可以帮助我们发现各种潜在问题.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 体验二(package开发)</title>
    <url>/2018/08/31/flutter-douban-2/</url>
    <content><![CDATA[<p>Flutter 只是一个 UI 框架,对于一些系统调用或者各自平台的的特有实现需要开发者自行编写 package,通过在 package 内实现不同平台的调用方式,以这样的方式进行适配.今天记录下怎样在不同平台编写 package.由于自己不会 iOS,所以只是实现一个简单的 Android Toast.iOS 端使用定时的UIAlertView去模拟.<br><a id="more"></a></p>
<h5 id="新建-package"><a href="#新建-package" class="headerlink" title="新建 package"></a>新建 package</h5><p>我的工具是 Android Studio,首先在项目根目录下new-&gt;module-&gt;选择 Fullter package,点击 next,然后看到这个界面<img src="https://def-201655.cos.ap-shanghai.myqcloud.com/fultter_2_new_package.png" alt="Flutter 目录结构">修改报名和描述,并且选择自己的 Flutter SDK 目录,最后点击 finish.一个新的 package 就新建完成了.当然如果使用 VSCode 的话也可以使用命令行新建 package.<br>package目录如下图所示<img src="https://def-201655.cos.ap-shanghai.myqcloud.com/flutter_2_package_module.png" alt="结构说明"></p>
<h5 id="Android-端实现-即在这这里编写原生调用代码"><a href="#Android-端实现-即在这这里编写原生调用代码" class="headerlink" title="Android 端实现,即在这这里编写原生调用代码"></a>Android 端实现,即在这这里编写原生调用代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterToastPlugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"FlutterToastPlugin"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Plugin registration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">        context = registrar.context();</span><br><span class="line">        <span class="keyword">final</span> MethodChannel channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">"flutter_toast"</span>);<span class="comment">//这里的  flutter_toast 包名不可修改,需要和iOS保持一直这样才可以调用生效.</span></span><br><span class="line">        channel.setMethodCallHandler(<span class="keyword">new</span> FlutterToastPlugin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">        String message = call.argument(<span class="string">"message"</span>);<span class="comment">//获取 flutter 传入的参数 </span></span><br><span class="line">        <span class="comment">//获取传入的方法名,调用相应的不同逻辑</span></span><br><span class="line">        <span class="keyword">switch</span> (call.method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"showToast"</span>:</span><br><span class="line">                Toast.makeText(context, message, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"showLongToast"</span>:</span><br><span class="line">                Toast.makeText(context, message, Toast.LENGTH_LONG).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"getPlatformVersion"</span>:</span><br><span class="line">                <span class="comment">//默认实现</span></span><br><span class="line">                result.success(<span class="string">"Android "</span> + android.os.Build.VERSION.RELEASE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.notImplemented();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="package-项目入口-我们可以在这里调用本身实现的功能-选择此文件-run-及时查看效果"><a href="#package-项目入口-我们可以在这里调用本身实现的功能-选择此文件-run-及时查看效果" class="headerlink" title="package 项目入口,我们可以在这里调用本身实现的功能,选择此文件 run 及时查看效果"></a>package 项目入口,我们可以在这里调用本身实现的功能,选择此文件 run 及时查看效果</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_toast/flutter_toast.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAppState createState() =&gt; <span class="keyword">new</span> _MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _platformVersion = <span class="string">'Unknown'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    initPlatformState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; initPlatformState() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> platformVersion;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现调用手机系统版本号</span></span><br><span class="line">      platformVersion = <span class="keyword">await</span> FlutterToast.platformVersion;</span><br><span class="line">    &#125; <span class="keyword">on</span> PlatformException &#123;</span><br><span class="line">      platformVersion = <span class="string">'Failed to get platform version.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mounted) <span class="keyword">return</span>;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _platformVersion = platformVersion;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//调用实现.showToast 即原生代码的的方法名 call.method, test toast 即原生代码的参数call.argument("message")</span></span><br><span class="line">    FlutterToast.showToast(<span class="string">"test toast"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'Plugin example app'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Text(<span class="string">'Running on: <span class="subst">$_platformVersion</span>\n'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="iOS-端实现-由于自己不会-Object-C-所以代码很简单-很容易看懂"><a href="#iOS-端实现-由于自己不会-Object-C-所以代码很简单-很容易看懂" class="headerlink" title="iOS 端实现 由于自己不会 Object-C 所以代码很简单,很容易看懂"></a>iOS 端实现 由于自己不会 Object-C 所以代码很简单,很容易看懂</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"FlutterToastPlugin.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FlutterToastPlugin</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)registerWithRegistrar:(<span class="built_in">NSObject</span>&lt;FlutterPluginRegistrar&gt;*)registrar &#123;</span><br><span class="line">  FlutterMethodChannel* channel = [FlutterMethodChannel</span><br><span class="line">      methodChannelWithName:<span class="string">@"flutter_toast"</span></span><br><span class="line">            binaryMessenger:[registrar messenger]];</span><br><span class="line">  FlutterToastPlugin* instance = [[FlutterToastPlugin alloc] init];</span><br><span class="line">  [registrar addMethodCallDelegate:instance channel:channel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">@"getPlatformVersion"</span> isEqualToString:call.method]) &#123;</span><br><span class="line">    <span class="comment">//默认实现</span></span><br><span class="line">    result([<span class="string">@"iOS "</span> stringByAppendingString:[[<span class="built_in">UIDevice</span> currentDevice] systemVersion]]);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>([<span class="string">@"showToast"</span> isEqualToString:call.method]) &#123;<span class="comment">//判断调用方法名</span></span><br><span class="line">    <span class="comment">//获取调用参数</span></span><br><span class="line">    <span class="built_in">NSString</span> *msg = call.arguments[<span class="string">@"message"</span>];</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc]</span><br><span class="line">                                 initWithTitle:<span class="literal">nil</span></span><br><span class="line">                                       message:msg</span><br><span class="line">                                      delegate:<span class="literal">nil</span></span><br><span class="line">                             cancelButtonTitle:<span class="literal">nil</span></span><br><span class="line">                             otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>];</span><br><span class="line">    [alert show];</span><br><span class="line">    <span class="keyword">double</span> duration = <span class="number">0.5</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [alert dismissWithClickedButtonIndex:<span class="number">0</span> animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>([<span class="string">@"showLongToast"</span> isEqualToString:call.method]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *msg = call.arguments[<span class="string">@"message"</span>];</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc]</span><br><span class="line">                                 initWithTitle:<span class="literal">nil</span></span><br><span class="line">                                       message:msg</span><br><span class="line">                                      delegate:<span class="literal">nil</span></span><br><span class="line">                             cancelButtonTitle:<span class="literal">nil</span></span><br><span class="line">                             otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>];</span><br><span class="line">    [alert show];</span><br><span class="line">    <span class="keyword">double</span> duration = <span class="number">1</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [alert dismissWithClickedButtonIndex:<span class="number">0</span> animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       result(FlutterMethodNotImplemented);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>若第一次把 package 运行在 iOS 端会提示错误,按照提示依次执行 <code>brew install cocoapods</code> 和 <code>pod setup</code> ,等待安装完成后,再次运行就可以在模拟器查看效果了.</p>
<h5 id="Flutter-桥接代码实现"><a href="#Flutter-桥接代码实现" class="headerlink" title="Flutter 桥接代码实现"></a>Flutter 桥接代码实现</h5> <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterToast</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel = <span class="keyword">const</span> MethodChannel(<span class="string">'flutter_toast'</span>);</span><br><span class="line">  <span class="comment">//默认实现</span></span><br><span class="line">  <span class="keyword">static</span> Future&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> platformVersion <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> version = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">'getPlatformVersion'</span>);</span><br><span class="line">    <span class="keyword">return</span> version;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对外提供调用的方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> showToast(<span class="built_in">String</span> message) &#123;</span><br><span class="line">      <span class="comment">//showToast 即调用原生的方法名, message 即调用原生的参数名,必须要一致否则无法调用</span></span><br><span class="line">    _channel.invokeMethod(<span class="string">"showToast"</span>, &#123;</span><br><span class="line">      <span class="string">"message"</span>: message,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> showLongToast(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    _channel.invokeMethod(<span class="string">"showLongToast"</span>, &#123;</span><br><span class="line">      <span class="string">"message"</span>: message,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Flutter 插件编写逻辑还是很简单,具体的实现方式还没有具体研究,有时间需要大概理解原理,这样也又便于编程思维的开拓.通过这个 demo,熟悉了插件编写方式,对于一些 Flutter 不支持的功能就可以让原生实现,比如嵌入WebView就可以通过原生提供实现.<br><a href="https://github.com/Thewhitelight/DouBanMovie">GitHub地址</a><br><a href="https://flutterstudio.app/" target="_blank" rel="noopener">在线编写Flutter实时预览</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>博客自定义域名支持 HTTPS</title>
    <url>/2018/08/30/github-page-https/</url>
    <content><![CDATA[<p>最早的博客使用 Jekyll 模版,但是感觉审美疲劳,样式太丑,所以迁移到了 Hexo 模版,目前对这个主题很满意.今年 GihHub 开始支持 https 加密访问博客了,所以抽空折腾了下自己的域名解析.<br><a id="more"></a></p>
<h4 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h4><p>网上方式讲解很多其实也很简单,在博客仓库的设置里下拉找到 Enforce HTTPS 勾选上,并且输入框里输入自己购买的域名,不需要<code>http://</code>或者<code>https://</code>,点击 save 后就可以等待了生成配置好了,第一次有点慢需要点时间.如果第一次设置自定义域名,需要在项目的根目录下新建 CNAME 文件,里面只需要输入自己的域名例如<code>libery.cn</code>即可.<br><img src="http://7qndg9.com1.z0.glb.clouddn.com/github_add_https.png" alt="github添加https"></p>
<h4 id="解析配置"><a href="#解析配置" class="headerlink" title="解析配置"></a>解析配置</h4><p>我的域名是在万网购买,所以解析也在阿里云里,原来的解析使用类型是 A 并且记录值是 ip 地址,替换为 HTTPS 后浏览器输入域名一直报错,所以怀疑是解析问题,然后将记录类型换为 CNAME,记录值改为博客初始名称也就仓库名称,点击确定.再次刷新博客就是 HTTPS 类型了.在 Chrome 里看着绿色的标记,很舒服了.<br><img src="http://7qndg9.com1.z0.glb.clouddn.com/github_https_cname.png" alt="域名解析"></p>
<h4 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h4><p>如果配置后还是无法访问,绿色的提示框会变成红色,里面有相应的提示,可以参考下解决相应问题.<br><img src="http://7qndg9.com1.z0.glb.clouddn.com/github_https_tip.png" alt="帮助"></p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>博客的图床用的是七牛云,但是七牛的图片外链是 http,导致博文的连接是 https 无法识别,如果要升级为 https,域名必须要在国内备案,很是恶心.所以将图床迁移到腾讯云,并且腾讯云提供上传的客户端,方便文件的上传和下载,腾讯云的存储服务在一定限额内是免费的,对于个人博客来说是完全够用的,不需要额外的付费即可满足.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Fultter 体验一(豆瓣电影 Api 简单使用)</title>
    <url>/2018/08/26/flutter-douban/</url>
    <content><![CDATA[<h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>Flutter 是 Google 开发的一套全新的跨平台、开源UI框架，支持 iOS、Android 系统开发，并且是未来新操作系统 Fuchsia 的默认开发套件。物联网是未来趋势,所以还是很看好 Flutter 项目,看到跨平台就感觉很熟悉了,有 Cordova、ReactNative、Weex 等前辈,但是Flutter的思路与上述的框架有本质却别.Flutter 使用全新的 Dart 语言开发,分别在 iOS、Android 实现了各自的 UI 控件、渲染逻辑,所以相比其他框架其性能更接近原生,美团的实际对比也确实说明了这个问题.记得前两年 Google 推出过基于 Dart 语言的 Sky 项目,当时写过 Demo 体验了下,然而确实昙花一现再也没有人讨论了,不过现在我估计是 Sky 项目孵化出了 Flutter 项目.</p>
<a id="more"></a>
<p>Dart 语言的使用相对 Java 开发者还是很友好的,看看官方的 Demo 和 Api 就可以上手开发了,既有静态语言的特性也有动态语言的特性,妈妈再也不用担心项目重构了.Dart 的页面刷新有点像 ReactNative 改变 State 则页面自动对比刷新.相同页面效果相比原生可以少写很多代码,并且官方支持Material Design 组件,很多交互逻辑已经默认实现,并且社区也有很多开源组件供开发着调用原生功能.Dart 支持 Hot Reload 功能,对于开发确实方便很多,美团文章中介绍了热刷新的限制,但是在我实际使用的时候还是发生了意想不到情况,我改变变量类型,但是保存后没有刷新的问题,导致我以为是代码写的有点问题改了几次,想到试着重新运行下,发现就正常识别了.</p>
<h4 id="Flutter-实践"><a href="#Flutter-实践" class="headerlink" title="Flutter 实践"></a>Flutter 实践</h4><p>Flutter 的安装参考中文网一步一步走下去,使用国内镜像几乎不会遇到什么坑,Android Studio 对其开发支持也十分友好,只需要下载 Flutter 和 Dart 插件后变可以编写代码了.<br>使用豆瓣 api,实现一个可以查看最近上映、top250 电影的简单App<img src="http://7qndg9.com1.z0.glb.clouddn.com/flutter_douban_yaml.png" alt="Flutter 包管理">上图是我项目的依赖包,其中 flutter_toast 是本地 Flutter package 桥接原生的 Toast,目前还没有适配 iOS,所以iOS端不能运行此项目.Dio 是一个网络请求框架,方便添加 header intercept 等.cached_network_image 是一个图片加载框架,可以设置缓存、加载动画之类.<br><img src="http://7qndg9.com1.z0.glb.clouddn.com/flutter_douban_dir.png" alt="项目目录结构">这是项目的目录结构,main.dart即项目入口.<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dou_ban_movie/douban/douban_hot_movies.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dou_ban_movie/douban/douban_top_movies.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序入口</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="comment">//使用 Material 组件,构建符合 Material Design 规范的 app</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Welcome to Flutter'</span>,</span><br><span class="line">      <span class="comment">//Android 中style.xml中的属性</span></span><br><span class="line">      theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: <span class="keyword">new</span> MyHomePage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; <span class="keyword">new</span> _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> mCurrentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Douban Movies"</span>),</span><br><span class="line">      ),</span><br><span class="line">      bottomNavigationBar: <span class="keyword">new</span> BottomNavigationBar(</span><br><span class="line">        items: [</span><br><span class="line">          <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.all_inclusive), title: <span class="keyword">new</span> Text(<span class="string">'HOT'</span>)),</span><br><span class="line">          <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.favorite), title: <span class="keyword">new</span> Text(<span class="string">'TOP'</span>))</span><br><span class="line">        ],</span><br><span class="line">        currentIndex: mCurrentIndex,</span><br><span class="line">        onTap: (index) &#123;</span><br><span class="line">            <span class="comment">//点击刷新tab</span></span><br><span class="line">          setState(() &#123;</span><br><span class="line">            mCurrentIndex = index;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">      body: _setupCurrentPage(mCurrentIndex),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _setupCurrentPage(<span class="built_in">int</span> mCurrentIndex) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (mCurrentIndex) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotMoviesPage();</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopMoviesPage();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HotMoviesPage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是首页的 Dart 代码,他不同于 Android 原生将页面样式和控制代码分离的逻辑,他是全都揉和在一起,更多的通过组件的组合来实现代码的复用.并且代码量大幅减少.可以加快开发速度.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Flutter对于提升开发效率确实有一定帮助,并且有 Google 加持,前景感觉也很不错,有新系统对其的支持,应该比其他跨平台方案更有优势,但是目前而言还是在成长期,还是不够稳定.跨平台开发确实很吸引人,感觉一个前端可以扛起很多原生开发的任务,对于 mvp 阶段的的项目确实很适合,但是对于中大型项目全部使用这种技术,其中的风险很大,前方各种坑等着趟过去,最后发现还是得走混合开发的路子.所以打算试试将 Flutter 作为 module 整合进原生里面,这样更加灵活.在原来ReactNative实践中也试过这样的做法,发现还是很不错,对于一些简单的功能用此开发很方便,对于复杂的功能可以直接切换到原生去做.</p>
<h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><p><img src="http://7qndg9.com1.z0.glb.clouddn.com/Screenshot_20180826-225527.jpg" alt="首页"><br><img src="http://7qndg9.com1.z0.glb.clouddn.com/Screenshot_20180826-225535.jpg" alt="详情页"><br><img src="http://7qndg9.com1.z0.glb.clouddn.com/Screenshot_20180826-225548.jpg" alt="查看图片"></p>
<h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/Thewhitelight/DouBanMovie">Github 地址</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://flutter-io.cn/" target="_blank" rel="noopener">Flutter 中国官网</a><br><a href="https://flutterchina.club/" target="_blank" rel="noopener">Flutter 中文网</a><br><a href="https://mp.weixin.qq.com/s/cJjKZCqc8UuzvEtxK1BJCw" target="_blank" rel="noopener">Flutter 的原理及美团的实践</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>代币的最佳组合</title>
    <url>/2018/08/10/coin-best-combination/</url>
    <content><![CDATA[<p>上一篇写了关于下单优惠的计算,项目迭代了几期,产品又提出要在下单后支付前还要有新的优惠措施,以一种不同面值的代币形式.买家可以选择不同面值的组合减免支付金额.</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>当用户下单后进入支付页面,系统优先计算出最划算的组合,供给用户选择.故实际付款金额=下单金额-代币组合值,代币不限数量,所以组合会有很多组合.例如有10,10,45,50,100的面值的代币,下单金额为75,最优组合为10,10,50.</p>
<a id="more"></a>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><h5 id="全排列方式"><a href="#全排列方式" class="headerlink" title="全排列方式"></a>全排列方式</h5><p>既然是多种组合,当我们使用迭代排列出全部组合,然后找出最优的解,但是这样的暴力穷举法,时间复杂度和空间复杂度都是很大,移动端性能本身就较弱,这样计算量和存储无法负担,并且计算时间长,没有现实意义.在测试用例中当有24个数字时, fullCombination 方法耗时平均15s左右,并且这是在 PC 执行的结果.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Coin&gt;&gt; fullCombination(List&lt;Coin&gt; lstSource) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = lstSource.size();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span> &lt;&lt; n;<span class="comment">//2的n次方</span></span><br><span class="line">    List&lt;List&lt;Coin&gt;&gt; lstResult = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        List&lt;Coin&gt; lstTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//i除以2的j次方</span></span><br><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lstTemp.add(lstSource.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lstResult.add(lstTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    lstResult.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> lstResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h5><p>我们可以把这个问题抽象成:给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合.candidates 中的每个数字在每个组合中只能使用一次.这个就是 LeetCode 中的组合总和II的题目,我们的需求完全一样,只需要小调整就可以使用,并且在时间复杂度O(n!)内,实际应用中可完全接受.使用上面的测试用例,得到最后的最优组合只需要20ms左右.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 面值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> denomination;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最优组合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 下单金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coins  所有代币</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最优组合中的代币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Coin&gt; <span class="title">getBestCombination</span><span class="params">(<span class="keyword">double</span> target, List&lt;Coin&gt; coins)</span> </span>&#123;</span><br><span class="line">        List&lt;Coin&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        List&lt;ArrayList&lt;Coin&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//所有代币组合</span></span><br><span class="line">        combinations = combinationSum(coins, target, combinations);</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;Integer, List&lt;Coin&gt;&gt; lastResult = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//根据组合中的代币 计算出总和按升序排列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Coin&gt; arrays : combinations) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Coin c : arrays) &#123;</span><br><span class="line">                temp += c.denomination;</span><br><span class="line">            &#125;</span><br><span class="line">            lastResult.put(temp, arrays);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取最后一个组合即为最优组合</span></span><br><span class="line">        result.addAll(lastResult.lastEntry().getValue());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ArrayList&lt;Coin&gt;&gt; combinationSum(List&lt;Coin&gt; coins,</span><br><span class="line">                                                 <span class="keyword">double</span> target,</span><br><span class="line">                                                 List&lt;ArrayList&lt;Coin&gt;&gt; result) &#123;</span><br><span class="line">        List&lt;ArrayList&lt;Coin&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        List&lt;Coin&gt; realCoins = <span class="keyword">new</span> ArrayList&lt;&gt;(coins.size());</span><br><span class="line">        <span class="keyword">for</span> (Coin c : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.denomination &lt;= target) &#123;</span><br><span class="line">                realCoins.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(realCoins, <span class="keyword">new</span> Comparator&lt;Coin&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Coin c1, Coin c2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(c1.denomination, c2.denomination);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> dfs(realCoins, <span class="number">0</span>, target, <span class="keyword">new</span> ArrayList&lt;Coin&gt;(<span class="number">10</span>), res, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ArrayList&lt;Coin&gt;&gt; dfs(List&lt;Coin&gt; candidates,</span><br><span class="line">                                      <span class="keyword">int</span> startIndex,</span><br><span class="line">                                      <span class="keyword">double</span> target,</span><br><span class="line">                                      List&lt;Coin&gt; combination,</span><br><span class="line">                                      List&lt;ArrayList&lt;Coin&gt;&gt; res, List&lt;ArrayList&lt;Coin&gt;&gt; result) &#123;</span><br><span class="line">        <span class="comment">//存储所有组合结果</span></span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex, size = candidates.size(); i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != startIndex &amp;&amp; candidates.get(i).denomination == candidates.get(i - <span class="number">1</span>).denomination) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates.get(i).denomination) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            combination.add(candidates.get(i));</span><br><span class="line">            dfs(candidates, i + <span class="number">1</span>, target - candidates.get(i).denomination, combination, res, result);</span><br><span class="line">            combination.remove(combination.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Thewhitelight/Tinder/blob/master/app/src/test/java/cn/libery/tinder/CoinTest.java">项目地址</a> 包含两种方法的所有代码和测试用例.</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">组合总和 II LeetCode</a><br><a href="https://blog.csdn.net/James_T_Kirk/article/details/76895209" target="_blank" rel="noopener">浅谈回溯与深度优先搜索</a><br><a href="https://www.jiuzhang.com/solution/combination-sum-ii/" target="_blank" rel="noopener">组合总和 II 解法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>根据订单金额匹配最划算的优惠券与定金</title>
    <url>/2018/08/09/best-price-calculation/</url>
    <content><![CDATA[<p>在电商平台通常会有一些优惠措施,比如以优惠券、定金或者代币之类的形式在下单时给予用户直观的减免金额.一般用户领取店铺优惠券,优惠券有不同的使用条件,满足条件时方可使用.定金为用户自己向店铺购买的形式,定金在特定的时间或者针对某个商品可以膨胀使用,膨胀出多余的部分相当商家让利,可以优惠购买.代币为商家以不同面值发放给用户,以抵扣下单金额.</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>假设某个店铺有好多不同使用条件的优惠券比如满20减去5,满20减10,每满20减5,每满20减21(其实我也不知道这个的意义什么,但是产品说就要发这样的券),然后用户还分别购买了20,30,60的定金,当用户下单金额为200元时,用户自己就难以选择,无法立即计算出支付最少的钱购买此单商品,所以需要我们计算匹配出一个最划算的组合给用户.当然优惠券和定金只能各选一个.</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>作为用户来讲,当然优先使用优惠券,因为优惠券为商家赠与而定金时自己购买,故支付金额=订单金额-优惠券的优惠金额(因为包含每满类型,所以不一是优惠券面值)-定金.那么大概思路就是定金和优惠券的组合,相当于两层for循环,然后按照这个公式算出支付金额大于等于零的那个值就可以了.思路时挺简单,但是优惠券的逻辑就有点复杂,以为优惠券自身就有好多种组合,例如满10减5,满10减8,每满10减8,满5减8,每满5减8,所以优惠券的顺序应该根据是否每满、优惠满足金额、优惠金额排序.</p>
<a id="more"></a>
<h4 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h4><p>先定义好优惠券、定金和最优组合的模型<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coupon</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠券id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠券满足金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> spending;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否每满 0为否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> every;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> discount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Booking</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定金Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定金金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestCombination</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用定金金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> bookingAmount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用优惠券金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> couponAmount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用的定金</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Booking booking;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用的优惠券</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Coupon coupon;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BestCombination</span><span class="params">(Booking booking, Coupon coupon, <span class="keyword">double</span> bookingAmount, <span class="keyword">double</span> couponAmount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.booking = booking;</span><br><span class="line">        <span class="keyword">this</span>.coupon = coupon;</span><br><span class="line">        <span class="keyword">this</span>.bookingAmount = bookingAmount;</span><br><span class="line">        <span class="keyword">this</span>.couponAmount = couponAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后先对优惠券和定金列表排序<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Coupon&gt; <span class="title">initCoupon</span><span class="params">(<span class="keyword">double</span> totalPrice, List&lt;Coupon&gt; coupons)</span> </span>&#123;</span><br><span class="line">        List&lt;Coupon&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (coupons.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Coupon b : coupons) &#123;</span><br><span class="line">                <span class="comment">//排除掉面值大于订单金额的券</span></span><br><span class="line">                <span class="keyword">if</span> (b.spending &lt;= totalPrice) &#123;</span><br><span class="line">                    result.add(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次根据是否每满、优惠满足金额、优惠金额排序</span></span><br><span class="line">        Collections.sort(result, <span class="keyword">new</span> Comparator&lt;Coupon&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Coupon o1, Coupon o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//每满券在前</span></span><br><span class="line">                <span class="keyword">int</span> compareEvery = Integer.compare(o2.every, o1.every);</span><br><span class="line">                <span class="keyword">if</span> (compareEvery == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//面值小的在前,为了近可能的不让用户使用定金</span></span><br><span class="line">                    <span class="keyword">int</span> compareSpending = Double.compare(o1.spending, o2.spending);</span><br><span class="line">                    <span class="keyword">if</span> (compareSpending == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Double.compare(o1.discount, o2.discount);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> compareSpending;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> compareEvery;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户可以选择不适用任何优惠券,所以需要添加此</span></span><br><span class="line">        Coupon emptyCoupon = <span class="keyword">new</span> Coupon();</span><br><span class="line">        emptyCoupon.discount = <span class="number">0</span>;</span><br><span class="line">        emptyCoupon.spending = <span class="number">0</span>;</span><br><span class="line">        emptyCoupon.id = <span class="string">"-1"</span>;</span><br><span class="line">        emptyCoupon.every = <span class="number">0</span>;</span><br><span class="line">        result.add(emptyCoupon);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定金只需要加入不使用定金的选项</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Booking&gt; <span class="title">initBooking</span><span class="params">(List&lt;Booking&gt; bookings)</span> </span>&#123;</span><br><span class="line">        List&lt;Booking&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (bookings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(bookings);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Booking emptyBooking = <span class="keyword">new</span> Booking();</span><br><span class="line">        emptyBooking.amount = <span class="number">0</span>;</span><br><span class="line">        emptyBooking.id = <span class="string">"-1"</span>;</span><br><span class="line">        result.add(emptyBooking);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后就可以根据订单金额、优惠券和定金计算出最优的组合<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计算最划算的组合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> totalPrice 订单金额</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> coupons    排好序的优惠券列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> bookings   定金列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 最优组合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BestCombination <span class="title">calculatorBestCombination</span><span class="params">(<span class="keyword">double</span> totalPrice, List&lt;Coupon&gt; coupons, List&lt;Booking&gt; bookings)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//TreeMap已对key进行排序,用来装填所有的组合结果,key为支付金额</span></span><br><span class="line">      SortedMap&lt;Double, BestCombination&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">double</span> couponPrice;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Coupon c : coupons) &#123;</span><br><span class="line">          <span class="keyword">for</span> (Booking b : bookings) &#123;</span><br><span class="line">              <span class="keyword">double</span> tempPrice = totalPrice;</span><br><span class="line">              <span class="keyword">if</span> (c.every == <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="comment">//每满券相当于多张券 张数*优惠金额</span></span><br><span class="line">                  couponPrice = Math.floor(tempPrice / c.spending) * c.discount;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  couponPrice = c.discount;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//订单金额-所有优惠金额</span></span><br><span class="line">              tempPrice = tempPrice - couponPrice;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//支付金额</span></span><br><span class="line">              tempPrice = tempPrice - b.amount;</span><br><span class="line">              <span class="comment">//当定金面值为正值且支付金额为负值时，排除此价格进入最优价格队列</span></span><br><span class="line">              <span class="keyword">if</span> (!(tempPrice &lt; <span class="number">0</span> &amp;&amp; b.amount &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (map.containsKey(tempPrice)) &#123;</span><br><span class="line">                      <span class="comment">//当支付金额相同时,如果组合内的定金大于将要插入的定金金额(意味着所使用的优惠券小)，则替换原有的组合</span></span><br><span class="line">                      BestCombination best = map.get(tempPrice);</span><br><span class="line">                      <span class="keyword">if</span> (best.bookingAmount &gt;= b.amount) &#123;</span><br><span class="line">                          map.put(tempPrice, <span class="keyword">new</span> BestCombination(b, c, b.amount, couponPrice));</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      map.put(tempPrice, <span class="keyword">new</span> BestCombination(b, c, b.amount, couponPrice));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      BestCombination bestCombination;</span><br><span class="line">      <span class="keyword">if</span> (map.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//组合队列为空，则无最优组合</span></span><br><span class="line">          bestCombination = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (map.firstKey() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//当组合队列第一个值大于零，则取第一个，此时为最优惠</span></span><br><span class="line">              bestCombination = map.get(map.firstKey());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">double</span> key = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;Double, BestCombination&gt; e : map.entrySet()) &#123;</span><br><span class="line">                  System.out.println(e.getKey() + <span class="string">" "</span> + e.getValue().toString());</span><br><span class="line">                  <span class="keyword">if</span> (e.getValue().booking.amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.getKey() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="comment">//定金大于零则说明优惠券使用了每满且类似10减20的类型 当支付金额小于零时</span></span><br><span class="line">                          key = e.getKey();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.getKey() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="comment">//定金等于0 且支付金额小于等于零</span></span><br><span class="line">                          key = e.getKey();</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              bestCombination = map.get(key);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> bestCombination;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>计算最划算的组合,重点在于计算前的数据排序、计算时替换相同支付金的组合和计算后最优组合的选择.<strong><em><a href="https://github.com/Thewhitelight/Tinder/blob/master/app/src/test/java/cn/libery/tinder/BestOfferTest.java">项目地址</a></em></strong>可以运行测试用例.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图片选择 Library</title>
    <url>/2018/08/06/avatar-select-img/</url>
    <content><![CDATA[<p>选择头像、图片时经常使用拍照和相册功能,但是由于 Android 碎片化问题,不同版本 API 有差异,并且在不同页面处理 onActivityResult 感觉太麻烦,所以就想着可以通过链式调用,将这些逻辑封装起来,让整个代码写起来简洁清晰明了,不至于好多类似代码重复,提高开发效率.</p>
<h4 id="选择图片存在的问题"><a href="#选择图片存在的问题" class="headerlink" title="选择图片存在的问题"></a>选择图片存在的问题</h4><h5 id="Android-6-0-运行时权限"><a href="#Android-6-0-运行时权限" class="headerlink" title="Android 6.0 运行时权限"></a>Android 6.0 运行时权限</h5><p>在 Android 6.0 中严格限制App的权限授予,读取 SD 卡、拍照、录音、定位、短信、通讯录等关键权限需要在代码中申请这些权限,否则会抛出异常导致程序奔溃,当 App 申请权限被拒绝后我们应该给用户弹出提示框,引导用户去设置页开启此权限,然后在 onRequestPermissionsResult 中处理回调结果.</p>
<h5 id="Android-7-0-StrictMode-问题"><a href="#Android-7-0-StrictMode-问题" class="headerlink" title="Android 7.0 StrictMode 问题"></a>Android 7.0 StrictMode 问题</h5><p>在 Android 7.0 中强制启用了被称作 StrictMode 的策略，带来的影响就是你的App对外无法暴露 file:// 类型的 URI,否则会出现 FileUriExposedException 异常,进程间应使用 FileProvider 共享文件.</p>
<h5 id="三星机型图片选择问题"><a href="#三星机型图片选择问题" class="headerlink" title="三星机型图片选择问题"></a>三星机型图片选择问题</h5><p>在三星机型中,当我们调用相机拍照后,获取的图片发现被旋转90度,所以需要获取图片的 ExifInterface 信息,然后根据 orientation 进行图片的角度旋转,使之方向正确.</p>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>针对以上问题写一个 library 就显得很有必要.方便在不用页面调用选择图片.在一个透明背景的 Activity 中处理以上问题,让调用方无感知以上问题,只用传入必要的设置条件最后拿到图片文件就可以,然后针对文件进行自己的业务逻辑操作即可.</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用方式 </span></span><br><span class="line">Avatar.getInstance()</span><br><span class="line">                   <span class="comment">//选择模式 ALL 拍照和相册 CAMERA 拍照 GALLERY 相册</span></span><br><span class="line">                   .setSelectMode(Avatar.ALL)</span><br><span class="line">                   <span class="comment">//文件目录名字 非必填 默认项目包名</span></span><br><span class="line">                   .setImageFileDir(<span class="string">"Tinder"</span>)</span><br><span class="line">                   <span class="comment">//是否剪裁</span></span><br><span class="line">                   .setHasCrop(<span class="keyword">true</span>)</span><br><span class="line">                   <span class="comment">//获取图片文件回调</span></span><br><span class="line">                   .imageFile &#123; imageFile -&gt;</span><br><span class="line">                       run &#123;</span><br><span class="line">                           Log.e(<span class="string">"file:"</span>, imageFile.absolutePath)</span><br><span class="line">                           img.setImageBitmap(BitmapFactory.decodeFile(imageFile.absolutePath))</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   .build(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>在 Avatar 中使用使用静态内部类单例模式,减少对象创建,并方便 Activity 中传回图片文件目录,SelectAvatarActivity 使用透明主题,并在处理权限请求与照片回调处理.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Avatar.java</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Avatar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Avatar <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AvatarHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Avatar INSTANCE = <span class="keyword">new</span> Avatar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">SelectAvatarActivity.java</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setImageFile 方法包级私有,故包外不可调用,保证封装</span></span><br><span class="line">    Avatar.getInstance().setImageFile(mAvatarFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择照片</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">            mOrigUri = Uri.fromFile(cameraFile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ContentValues contentValues = <span class="keyword">new</span> ContentValues(<span class="number">1</span>);</span><br><span class="line">            contentValues.put(MediaStore.Images.Media.DATA, cameraFile.getAbsolutePath());</span><br><span class="line">            mOrigUri = getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues);</span><br><span class="line">        &#125;</span><br><span class="line">        intent.putExtra(MediaStore.EXTRA_OUTPUT, mOrigUri);</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE_GET_IMAGE_CAMERA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择相册</span></span><br><span class="line">    Intent intent;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">            intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        startActivityForResult(intent, REQUEST_CODE_GET_IMAGE_SDCARD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过图片路径,获取图片ExifInterface信息得到旋转角度,使用Matrix旋转生成新的图片保存</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readPictureDegree</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExifInterface exifInterface = <span class="keyword">new</span> ExifInterface(path);</span><br><span class="line">            <span class="keyword">int</span> orientation = exifInterface.getAttributeInt(</span><br><span class="line">                    ExifInterface.TAG_ORIENTATION,</span><br><span class="line">                    ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line">            <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">                <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">                    degree = <span class="number">90</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">                    degree = <span class="number">180</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">                    degree = <span class="number">270</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ImageUtil.java </span><br><span class="line">    <span class="comment">//旋转图片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">rotateImageView</span><span class="params">(<span class="keyword">int</span> angle, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">        matrix.postRotate(angle);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 透明主题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"TransparentTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowIsTranslucent"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowAnimationStyle"</span>&gt;</span>@android:style/Animation.Translucent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowNoTitle"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowContentOverlay"</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- FileProvider 适配7.0--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.fileProvider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resource</span>=<span class="string">"@xml/provider_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- provider_paths.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 为了方便直接使用 root-path 对所有文件授权,当然安全起见考虑还是不要这么写,使用external-path范围越小越好--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root-path</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"root_path"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>&lt;paths&gt;</code> 中可以添加<code>&lt;files-path&gt;</code> 分享app内部的存储; <code>&lt;external-path&gt;</code> 分享外部的存储; <code>&lt;cache-path&gt;</code>分享内部缓存目录.根据不同的需求对文件夹进行授权访问.</p>
<p>当封装好这些功能后,在调用页面获取图片的代码最多短短是几行,而不像原来需要上百行的处理各种问题,并且 API 变动时,只需要改动 library 就可以完成适配.<br><strong><a href="https://github.com/Thewhitelight/Tinder">项目地址</a></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>OKHttp动态切换Host</title>
    <url>/2018/07/21/okhttp-host-switch/</url>
    <content><![CDATA[<p>在日常开发中会分测试、预发、生产等环境,不同环境下请求 Host 不一致,原来的解决方案是通过定制不同的 Flavors,通过添加 applicationIdSuffix 可以让多个 App 同时安装在手机方便测试,但是又产生新的问题,每次都要打包上传不同的 App 让测试安装,这样感觉略显麻烦,所以就想到能不能 App 内部做环境切换,这样切换自如,无需重新打包.</p>
<a id="more"></a>
<h4 id="使用官方提供的-url修改Host"><a href="#使用官方提供的-url修改Host" class="headerlink" title="使用官方提供的@url修改Host"></a>使用官方提供的@url修改Host</h4><p>官方提供@url方法来动态改变请求的url,但是不符合我们的需求,使用@url只适合修改个别接口的情况,我们这样支持全部接口的修改显然工作量太大,几乎无法维护,如果App中使用第三方图片或者文件上传可以使用这个方法,只在个别接口修改url使用起来比较方便.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call&lt;ResponseBody&gt; <span class="title">uploadImg</span><span class="params">(@Url String url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="封装不同-Host-的-OKHttpClient"><a href="#封装不同-Host-的-OKHttpClient" class="headerlink" title="封装不同 Host 的 OKHttpClient"></a>封装不同 Host 的 OKHttpClient</h4><p>由于 OKHttp 不支持动态切换h ost 并且 api 请求为单例模式,然后想到封装3个不同Host的OkHttpClient,然后通过策略模式去实现不同的请求调用,但是这样总感觉不太优雅,又占用内存.</p>
<h4 id="利用-Interceptor-切换-Host"><a href="#利用-Interceptor-切换-Host" class="headerlink" title="利用 Interceptor 切换 Host"></a>利用 Interceptor 切换 Host</h4><p>继续想会不会有通过改变 api 的方式去实现这个功能,然后突然想到我们在添加 Cookie 时用到的 Interceptor,既然它每次都会拦截请求,那么我们可以在拦截到请求时换掉 Host,实现我们想要的功能.有了思路就可以动手开始看源码改造了.</p>
<p>在 Intercept 方法中通过 Chain获取 Request,修改 Request 中的 HttpUrl 来改变 Host.HttpUrl类用于获取 Host、端口,URL解析,和处理URL字符串等,但是发现HttpUrl,URL,Request类中的变量都是私有并且没有修改方法,只能通过反射方法去修改.不多说直接上代码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Api定义好不同的环境的Host</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String mHost = Api.getHost();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"host"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外提供动态修改host</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host 设置的新host</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">        mHost = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        <span class="comment">//根据自己的判断逻辑 是否修改host</span></span><br><span class="line">        <span class="keyword">if</span> (AppUtil.canCheckoutHost() &amp;&amp; !mHost.equals(Api.getHost())) &#123;</span><br><span class="line">            request = replaceHost(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Request <span class="title">replaceHost</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        HttpUrl httpUrl = request.url();</span><br><span class="line">        URL url = httpUrl.url();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//反射修改URL中的Host</span></span><br><span class="line">            Class&lt;?&gt; urlClz = url.getClass();</span><br><span class="line">            Field urlHost = urlClz.getDeclaredField(HOST);</span><br><span class="line">            urlHost.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            urlHost.set(url, mHost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射修改HttpUrl中的Host</span></span><br><span class="line">            Class&lt;?&gt; httpUrlClz = httpUrl.getClass();</span><br><span class="line">            Field httpUrlHost = httpUrlClz.≈getDeclaredField(HOST);</span><br><span class="line">            httpUrlHost.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            httpUrlHost.set(httpUrl, mHost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射修改Request中的HttpUrl</span></span><br><span class="line">            Class&lt;?&gt; requestUrlClz = request.getClass();</span><br><span class="line">            Field requestUrl = requestUrlClz.getDeclaredField(<span class="string">"url"</span>);</span><br><span class="line">            requestUrl.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            requestUrl.set(request, httpUrl);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用修改后的HttpUrl构造新的HttpUrl</span></span><br><span class="line">        request = request.newBuilder().url(httpUrl).build();</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在OkHttpClient.Builder中加入即可完成动态切换</span></span><br><span class="line">builder.addInterceptor(<span class="keyword">new</span> DynamicInterceptor());</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a href="https://github.com/Thewhitelight/DynamicRetrofitHost.git">项目地址</a> 目前这个方法已经满足需求,在MainActivity中使用悬浮按钮去动态切换Host很实用.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OKHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式简单记录</title>
    <url>/2018/07/20/android-design-pattern/</url>
    <content><![CDATA[<h2 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h2><ul>
<li>单一职责原则(SRP):一个类应该仅有一个引起它变化的原因。</li>
<li>开闭原则(OCP):软件中的对象应该对于扩展是开放的，对于修改是封闭的。</li>
<li>里氏替换原则(LSP):所有引用基类的地方必须能透明的使用其子类。</li>
<li>依赖倒置原则(DIP):模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。</li>
<li>接口隔离原则(ISP):客户端不应该依赖它不需要的接口。</li>
<li>迪米特原则(LOD):一个对象应该对其他对象有最少的了解。</li>
</ul>
<p>在开发过程中把握平衡点，使系统可以具有高稳定性、高可扩展性并且高内聚、低耦合，在不断迭代中完善架构。<br><a id="more"></a></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>定义:确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<p>场景:对于创建一个对象需要消耗过多的资源，可以使用此模式，如：访问数据库、网络、IO。</p>
<p>单例模式特点：</p>
<ul>
<li>构造函数私有</li>
<li>通过一个静态方法或者枚举返回单例类对象</li>
<li>确保单利类的对象有且只有一个</li>
<li>确保单利类对象在反序列化时不会重新创建对象</li>
</ul>
<p>一般最常用的为静态内部类单例模式，可以确保线程安全、对象唯一、同时也延迟实例化。<br>Android中使用单例模式最直观则是Application,但如果应用为多进程时，则onCreate方法执行多次。单例模式持有Context时应持有Application Context，避免内存泄漏。</p>
<h2 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h2><p>定义:将一个复杂对象的构建与它的表示分离，使得同样的的构建过程可以创建不同的表示。</p>
<p>场景:</p>
<ul>
<li>相同方法，不同执行顺序，产生不同的事件结果</li>
<li>多个参数装配到一个对象中，产生的结果不相同</li>
<li>对象复杂，参数多且有默认值</li>
</ul>
<p>Android中最常见的为AlertDialog.Builder,虽然不是经典实现，但灵活运用设计模式则十分重要。在实际开发中很多时候为了与应用设计统一，会替换系统AlertDialog样式，这时可以运用Builder模式，构建统一Dialog,方便调用。Intent有时需要携带很多参数在页面间传递，这时使用Builder模式也会更加清晰。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>定义:用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
<p>场景:</p>
<ul>
<li>类初始化需要消耗很多资源</li>
<li>new一个对象需要非常繁琐的数据准备或者访问权限</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值，考虑使用原型模式拷贝多个对象提供给调用者</li>
</ul>
<p>当对象实现Cloneable接口时，其构造函数不会执行。为减少错误，尽量使用深拷贝，避免操做副本时影响原始对象。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义:定义一个用于创建对象的接口，让子类决定实例化哪个类。</p>
<p>场景:生成复杂对象的地方</p>
<p>清晰定义一个产品的层级结构，实践中可以将具有相同模式的Activity、View、数据存储等进行封装。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>定义:为创建一组相关或者互相依赖的对象提供一个接口，而不需要指定它们的具体类。</p>
<p>场景:一个对象族有相同的约束时可以使用</p>
<p>清晰定义一个产品族的层级结构。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义:定义一系列算法，并将其封装且可以互相替换。</p>
<p>场景:</p>
<ul>
<li>针对同一类型问题多种处理方式</li>
<li>需要安全的封装多种同一类型的操作时</li>
<li>同一抽象类有多个子类，且需要使用if-else或者switch-case选择具体子类时</li>
</ul>
<p>可以在相通的抽象下实现不同的策略，如对于各种第三分享的调用可以使用策略模式。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>定义:当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
<p>场景:</p>
<ul>
<li>一个对象的行为取决于它的状态，并且他必须在运行时更具状态改变他的行为</li>
<li>代码中包含大量与对象有关的条件语句</li>
</ul>
<p>不同的状态下对于同一行为有不同的响应，如用户登录状态，复杂界面View的显示与隐藏，用多态替换条件语句。</p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>定义:使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链条传递该请求，只到有对象处理为止。</p>
<p>场景:</p>
<ul>
<li>多个对象可以处理同一请求，但具体有哪个对象处理则在运行时动态决定</li>
<li>在请求处理者不明确的情况下向多个对象中的一个提交一个请求</li>
<li>需要动态指定一组对象处理请求</li>
</ul>
<p>Android对于事件的分发处理则类似于责任链模式，若处理者太多则会影响性能。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>定义:给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p>
<p>场景:</p>
<ul>
<li>如果某个简单的语言需要解释执行而且可以将该语言中的语句表示为一个抽象语法树时可以考虑使用解释器模式</li>
<li>在某些特定的领域出现不断重复的问题时，可以将该领域的问题转化为一种语法规则下的语句，然后构建解释器来解释该语句</li>
</ul>
<p>Android中AndroidManifest的解析则可以看作为对解释器模式的运用。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>定义:将一个请求分装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求队列或者记录请求日志，以及支持可撤销的操作。</p>
<p>场景:</p>
<ul>
<li>需要抽象出待执行的动作，然后以参数的形式提供出来——类似于过程设计中的回调机制，而命令模式正是回调机制的一个面向对象的替代品</li>
<li>在不同的时刻指定、排列和执行请求。一个命令对象可以有与初始请求无关的生存期</li>
<li>需要支持取消操作</li>
<li>支持修改日志功能，这样系统崩溃时，这些修改可以被重新做一遍</li>
<li>需要支持事务操作</li>
</ul>
<p>当一起请求操做较多的对象时可以考虑使用命令模式，使代码条理清晰，增强代码可读性。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义:定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<p>场景:</p>
<ul>
<li>关联行为场景，关联行为是可拆分，而不是组合关系</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景</li>
</ul>
<p>Android中BroadcastReceiver与ListView数据更新这是典型的观察者模式。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>定义:在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可以将该对象恢复到原来保存的状态。</p>
<p>场景:</p>
<ul>
<li>需要保存一个对象在某一个时刻的状态或者部分状态</li>
<li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态</li>
</ul>
<p>Android中Activity、Fragment、View的状态保存为备忘录模式，对于需要回滚操作使此模式可以很好的支持。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>定义:提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<p>场景:遍历一个容器对象时</p>
<p>Android中数据库查询会使用到Cursor,但项目通常使用第三方ORM封装,几乎很少使用其模式。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义:定义一个操做中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>场景:</p>
<ul>
<li>多个子类有公有的方法，并且逻辑基本相同</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现</li>
<li>重构时，模板方法 模式是一个经常使用的模板，把相同的代码抽取到父类中，然后通过钩子函数约束行为</li>
</ul>
<p>Android中Activity、Fragment和AsyncTask，都是对流程进行封装，便于调用。重构时可以将子类中相同的方法上移到父类中。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>定义:封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<p>场景:</p>
<ul>
<li>对象结构比较稳定，但经常需要在此对象结构上定义新的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类</li>
</ul>
<p>将数据结构和数据操作分离，实际开发中很少使用该模式。</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>定义:定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示的相互引用，从而使其耦合性松散，而且可以独立改变他们之间的交互。</p>
<p>场景:</p>
<ul>
<li>一组定义良好的对象，需要进行复杂的通信</li>
<li>定制一个分布在多个类中的行为，而不想生成太多的子类</li>
</ul>
<p>Android中Binder机制也使用到了中介者模式，开发中对复杂页面的View状态改变也可以使用此模式，让代码更清晰表达。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>定义:为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>场景:当无法或不想直接访问某个对象或访问某个对象在困难时可以通过一个代理对象来间接访问，为保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口</p>
<p>Android中AMS也用到了此模式，最常用的Retrofit也用到了动态代理，此模式在应用过程中最为常见。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>定义:将对象组合成树形以表示“部分-整体”的层次结构，是的用户对单个对象和组合对象的使用更有一致性。</p>
<p>场景:</p>
<ul>
<li>表示对象的部分-整体层次结构时</li>
<li>从一个整体中能够独立出部分模块或者功能的场景</li>
</ul>
<p>Android中View与ViewGroup则是组合模式的提现，自定义View也可使用此模式。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>定义:把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
<p>场景:</p>
<ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要，即借口不兼容</li>
<li>想要建立一个可以重复使用的类，用于一些彼此间没有太大关联的一些类，包括一些在将来引进的类一起工作</li>
<li>需要一个统一的输出接口，而输入端的类型不可预知</li>
</ul>
<p>ListView和RecyclerView均为此模式的应用，开发中较少用到此模式，在调用一些第三方时使用此模式，例如分享到不同平台具体方式不同，可以使用转换成同一个接口，方便调用替换。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>定义:动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。</p>
<p>场景:需要透明且动态扩展类的功能时</p>
<p>Android里ContextWrapper则应用了装饰模式，对于类的一些初始化方法可以看作是此模式的实践。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>定义:使用共享对象可有效地支持大量地细粒度的对象。</p>
<p>场景:</p>
<ul>
<li>系统中存在大量的相似模式</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份</li>
<li>需要缓冲池场景</li>
</ul>
<p>Message应用此模式，所有的对象比较是否相等时必须使用equals,如果使用==则会出现由于常量池引起的不相等。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>定义:要求一个子系统的外部预期内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更容易使用。</p>
<p>场景:</p>
<ul>
<li>为一个复杂子系统提供一个简单接口，对外隐藏子系统的具体实现、隔离变化</li>
<li>当需要构建一个层次结构的子系统时，使用外观模式定义子系统的每层入口点，从而简化了他们之间的依赖关系</li>
</ul>
<p>ContextImpl应用了外观模式,对于复杂的模块使用Module解耦也可以看做是外观模式。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>定义:将抽象部分和实现部分分离，使它们都可以独立地变化。</p>
<p>场景:</p>
<ul>
<li>当一个对象有多个变化因素的时候，通过抽象这些变化因素，将依赖具体实现，修改为依赖抽象</li>
<li>当某个变化因素在多个对象中共存时</li>
<li>当我们期望一个对象的多个变化因素可以动态的变化，而不影响客户的程序的使用时</li>
</ul>
<p>Android中音视频播放就类似桥接模式，使应用层api可以调用底层。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code 阅读笔记(2)</title>
    <url>/2018/07/20/clean-code-2/</url>
    <content><![CDATA[<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul>
<li>将系统的构造与使用分开，如依赖注入(DI)、控制反转(IoC)</li>
<li>保证系统良好的的扩容性，使用面向切面编程(AOP)方式编程</li>
</ul>
<p>对于系统这章不能透彻理解，平时对于架构没有深入理解，系统应该是随着业务的变化而变化，没必要先做大设计而限制后续设计思路，保证大概可工作的最简单方案即最合适。</p>
<a id="more"></a>
<h2 id="迭进"><a href="#迭进" class="headerlink" title="迭进"></a>迭进</h2><ul>
<li>运行所有测试，可以导向类保持短小且单一</li>
<li>不可重复，尽量抽象如使用模板方法</li>
<li>表达程序员的意图，使用标准的命名法、斟酌好的名称</li>
<li>尽可能减少类和方法的数量，按照实际平衡忌教条</li>
</ul>
<p>实践中很少能一蹴而就，在不断地迭代中改进是最好的方式，时常关注代码质量。</p>
<h2 id="味道和启发"><a href="#味道和启发" class="headerlink" title="味道和启发"></a>味道和启发</h2><ul>
<li>注释<ul>
<li>不恰当的信息删除掉，只放描述有关代码和设计的技术性信息</li>
<li>废弃的注释尽快更新或删除</li>
<li>注释应提及代码自身未提及的信息</li>
<li>保持注释简洁</li>
<li>及时删除注释掉的代码</li>
</ul>
</li>
<li>函数<ul>
<li>避免过多参数，没有最佳，一个次之，尽量避免三个以上参数</li>
<li>避免输出参数</li>
<li>避免使用boolean型参数，使用多个函数优于想单个函数传递参数选择函数行为</li>
<li>删除未调用的函数</li>
</ul>
</li>
<li>一般性问题<ul>
<li>减少文件中额外语言的数量和范围</li>
<li>遵循“最小惊异原则”，命名和行为一致</li>
<li>了解边界，别依赖直觉</li>
<li>重视安全</li>
<li>消除重复</li>
<li>创建分离较高层级一般性概念和较低层级细节性的抽象模型</li>
<li>较高层级基类概念不依赖于较低层级派生类概念</li>
<li>保持接口紧凑，隐藏实现，减少耦合</li>
<li>及时检查删除死代码</li>
<li>垂直分隔</li>
<li>命名前后一致</li>
<li>保持文件整洁，良好的组织</li>
<li>代码尽可能的具有表达力</li>
<li>倾向使用非静态函数，如果使用确保没机会打算其有多态行为</li>
<li>使用解释性变量</li>
<li>函数名称应清晰表达其行为</li>
<li>将逻辑依赖改为物理依赖</li>
<li>用多态替代if/else和switch/case</li>
<li>用命名常量替代魔法数</li>
<li>结构甚于约定</li>
<li>分装条件</li>
<li>避免否定性条件</li>
<li>函数只做一件事</li>
<li>掩盖时序耦合</li>
<li>封装边界条件</li>
<li>函数应该只在一个抽象层级上</li>
<li>在较高层放置可配置资源</li>
<li>避免传递浏览</li>
</ul>
</li>
</ul>
<p>在实践过程中应该时刻注意这些问题，避免代码腐烂蔓延。让代码时刻保持清晰的意图，避免猜测。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>编程技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code 阅读笔记(1)</title>
    <url>/2018/07/20/clean-code-1/</url>
    <content><![CDATA[<p>读的技术书、社科书，现在想想总感觉能回忆起来的太少，看过也就当看过了，没有内化为自己的内容。所以这本书起开始做读书笔记，也便于以后查阅。看了下上篇博文距离现在竟然有一年多了，真是快废了，还好现在拾起来。</p>
<h1 id="整洁代码："><a href="#整洁代码：" class="headerlink" title="整洁代码："></a>整洁代码：</h1><p>外表或举止上令人愉悦的优美和雅观；令人愉悦的精致和简单 –Bjarne Stroustrup</p>
<p>如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。  –Ward Cunningham</p>
<p>这便是书写代码的最高境界，在实践过程中确实不易,唯有持之以恒的坚持自省，正如不易确实需要一个军规<strong>让营地比你来时更干净</strong>，在每次修改时心里默念这句，对看到繁琐的代码及时梳理使其变得简洁、清晰、明了，或许仅仅重命名就可以有这样的效果。</p>
<a id="more"></a>
<h2 id="命名："><a href="#命名：" class="headerlink" title="命名："></a>命名：</h2><ul>
<li>名副其实：在上下文中能明确表示其含义，无歧义</li>
<li>避免误导：命名准确，减少相似性，避免猜测</li>
<li>做有意义的区分：如UserInfo比起User则显得没什么意义</li>
<li>使用读的出来的名称：减少诡异的缩写，除非约定俗成。</li>
<li>使用可搜索的名称：作用域越小，命名可以适当简单、短小</li>
<li>类名为名词</li>
<li>方法名为动词或者动词短语</li>
<li>相同概念对应同一名词</li>
<li>添加有意义的语境</li>
</ul>
<p>命名让人感觉很简单，但是在实践过程中，却发现是如此的令人头痛，找到一个合理的字词、短语是如此的困难，对于理解上下文是如此的重要，当命名变得有意义，可以让我们减少大量注释去解释代码到底做了什么。当在代码里看到不合理的命名时，不要想着下次有时间再改，而是立马修改，下次相当于没有下次。烂代码就是这样慢慢腐烂，最后如沼泽一般，你想穿过时会一不小心陷入其中，难以脱身。所以现在便是改变的最好时机。</p>
<h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><ul>
<li>短小：当大块的函数拆分后，命名有意义的短小函数时，便相当于注释，更容易理解其到底做了什么，怎么做，只要函数内做同级逻辑的事情便可无需拆分</li>
<li>只做一件事：做好这件事</li>
<li>每个函数一个抽象层级：描述当前抽象层级，并引用下一层级的后续</li>
<li>Switch:根据上下文可以将switch放置在抽象工厂，但是这样会造成代码量的增加，可以根据实际情况取舍</li>
<li>使用描述性的名称命名函数，函数名称字数多也无所谓，OC函数名更长</li>
<li>尽量使函数参数少于三个，对于过多的参数可以使用Builder模式</li>
</ul>
<p>刚开始对于函数规模不好把握，可以先实现功能，然后再优化，使其看起来简洁明快，如沐春风，毕竟编程时很多时候在于浏览原来代码的逻辑，这样清晰的代码可以加快开发速度和愉悦身心。</p>
<h2 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h2><ul>
<li>用代码阐述目的，而不是通过大量的注释</li>
<li>好的注释：法律信息、意图的注释、警示</li>
<li>坏的注释：没有表达具体的含义、误导性注释、日志式注释、废话玩笑式注释、滥用位置标记、归属和签名、注释掉的代码</li>
</ul>
<p>对于坏的注释深有体会，当代码多个版本迭代后，注释和代码已经完全不是一个含义式，注释仍旧在，很容易误导对代码的理解。在版本管理工具完善的现在，对于无用代码完全不用担心删除以后要用到时找不到的尴尬，当然必须有个规范的Commit记录，便于找回代码。</p>
<h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><ul>
<li>垂直方向：方法间空一行；函数调用互相靠近(调用者在前，被调用者在后)；变量声明靠近其使用位置，实体变量声明在类顶部；相关概念代码 放在一起</li>
<li>水平方向：设置代码显示最大列；当方法层级过多导致大量缩进时，抽取为方法，减少方法内缩进层级；</li>
</ul>
<p>书写代码有良好的格式十分重要，有的项目里Tab和Space混用，导致不同文件格式看起来十分别扭，对于未格式化的代码堆积在一起，很难看清调用逻辑，写完代码格式化是个好的习惯，当然对于不完美的地方可以手动修改，当下次打开时会提高阅读速度，项目格式统一十分有必要，可以用CheckStyle等工具约束代码规范。</p>
<h2 id="对象和数据结构："><a href="#对象和数据结构：" class="headerlink" title="对象和数据结构："></a>对象和数据结构：</h2><ul>
<li>数据抽象：暴露实现，隐藏数据结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCartesian</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getTheta</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">viod <span class="title">setPolar</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> theta)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>减少过程式编码，过程式编码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下新类，反之亦然</li>
<li>数据传送对象，例如避免使用ORM时，类内既有公共变量也有save、find等方法</li>
</ul>
<p>在实现过程中要很把握这点确实很难，根据上下文环境进行相应的取舍，对于现实的编程确实更为有利点。</p>
<h2 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h2><ul>
<li>使用异常而非错误码</li>
<li>先写Try-Catch-Finally</li>
<li>使用未受检异常</li>
<li>别返回null值</li>
<li>别传递null值</li>
</ul>
<p>异常处理在实践过程中确实有时能救一命，但是很多的异常代码和正常逻辑混合，需要小心将其尽量分离，对于null传递，入参中做判空处理，以防NPE,在团队协作过程中最好有统一的定义怎样处理，大量的判空处理确实显得无意义但是有时没办法的事情。</p>
<h2 id="边界："><a href="#边界：" class="headerlink" title="边界："></a>边界：</h2><p>在以往编程中确实很少注意边界问题，对于接入第三方，没有在意其影响而去编写相应的TestCase，当第三方api有较大的改动时，自己代码也会发生很大改动，并且再次回归测试，耗费大量时间。对待第三方接入应该尽量封装，免受它的控制。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>保持测试整洁，明确、简洁有较高的可读性，遵循构造-操做-检验模式</li>
<li>FIRST:快速、独立、可重复、自足验证、及时</li>
</ul>
<p>在平时开发中，对于单元测试实践的太少，最多只测试一些工具类，由于Android特殊性，相对测试用例编写不方便。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>符合自顶向下原则</li>
<li>保持变量和工具函数的私有性，但不应执着于此</li>
<li>单一权责原则(SRP)，类或者模块应有且只有一条加以修改的理由</li>
<li>内聚：类应只有少量的实体变量，内聚性应保持在较高的位置</li>
<li>依赖倒置原则(DIP)：类应当依赖于抽象而不是具体细节</li>
</ul>
<p>对于SRP、DIP只有在了解业务情况下，多次重构得到合适的方案，时常保持重构会对代码质量有很大的帮助。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>编程技巧</tag>
      </tags>
  </entry>
</search>
